zachryiixixiiwood@gmail.com
###/starts/Runs::/Build::Script::/build_script:const:name:on::"''
'# -Workflow_call:-on- Toggles-the-runner-on:on::
# - " This workflow contains a single job called build‚Äù
"::Build:":"a-multi-line-one-line-script"
    # The type of runner that the job will run on
    Runs-on: ubuntu-latest
    # Steps represent a sequence of tasks that will be executed as part of the job
    Step: uses: action/checksout@v2
      # Run: name
name: build-and-deployee
Jobs: uses: "#-trigger-to-toggle-actions-on workflow_call:On:-on-:
'"Steps':' uses: -
Runs: a multi-one-line-action_script'
echo: hello World!'
name:  ü™Å'
run-on:  ubuntu-latest'
Request: release
-package-with: Python.js
-  push: iixixi/ZachryTylerWood/.github/workflows/
-    branches: [ main ]
+Launch:  
+bundle-with: Python.js
name: Repo'-sync
repo'Sync:=={data'@iixixi/ZachryTylerWood/.github/workflows/
+    branches:[ mainbranch ]
   Pull_request:
-       Branches: [ mainbranch ]
+    branches:[ trunk ]
 Jobs:
-       Runs-on:‚Äô ‚Äò- steps:
     Name: ‚ú® Engineering
     To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
@@ -33,23 +26,24 @@ jobs:
         Ruby-version: 2.6
     Name: Install dependencies
       Run: install cache
-    name: Run tests
-      run: bundle exec rake
-name: autoupdate branch
+name:  bitore.sig
+run: bundle exec rake
+name:autoupdate branch
 On:
   Push:
     Branches:
-         - main
+      [main]
Job: -steps
Autoupdate:
name: autoupdates
Runs-on: package.yam/pkg.js        
$Rakefile: $(((c)(r)))
   Pull: ‚ú®Engineering
name: deno.yml
on:
Pushs:
Branch: [mainbranch]
pull_request:
branches:  [trunk]
Job: Tests
Tests: test'@CI
Runs-on: ubuntu-latest

    Steps:
-    Name: Setup repo
        Uses: actions/checkout@v2

-    Name: Setup Deno
        # uses: denoland/setup-deno@v1
        Uses: denoland/setup-deno@004814556e37c54a2f6e31384c9e18e9833173669
        With:
          Deno-version: v1.x
      # Uncomment this step to verify the use of ‚Äòdeno fmt‚Äô on each commit.
      # - name: Verify formatting
      #   run: deno fmt ‚Äìcheck
      - name: Run linter
      -  run: deno lint
      -  name: Run tests
        - run: deno test -A ‚Äìunstable
Loading complete
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# üíÅ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image an
-'Runs: 
workflow_call: angulaura
'name: Vienna''
-on:
  push:
    branches:
      - main
      - dev-1
  pull_request:
    branches:
      - main
jobs:
-
 const: build_script:
 build_script: Automates
Automate:
:Automate-Fix::'*logs::All:''
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .eslintcache
          key: lint-${{ env.GITHUB_SHA }}
          restore-keys: lint-
      - run: yarn lint
  basic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      -       matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [10.x, 17.x]
        part: [a, b]
        include:
          - os: ubuntu-latest
            node-version: 16.x
            part: a
          - os: ubuntu-latest
            node-version: 14.x
            part: a
          - os: ubuntu-latest
            node-version: 12.x
      
      - run:  package.json/pkh.js

      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-integration-${{ env.GITHUB_SHA }}
          restore-keys
      - run:: build-and-deployee''
name help wanted
echo: Hello world!
test: @travis.yml
name CI
git fetch origin
git checkout -b trunk-1-2 origin/trunk-1-2
git merge patch-1test.
title: automates updaate
on:
  push:
    branches:
      - main
jobs:
  autoupdate:
    name: autoupdate
    runs-on: ubuntu-18.04
    steps:
      - uses: 
        env:'on:''
  'push:''
    'branches: '[mainbranch']''
  'pull_request:''
    'branches: '[trunk']''
'jobs:''
  'test:''
    'runs-on:' Python.js''
''#' token:' '$'{'{'('(c')'(r')')'}'}''
''#' runs a test on Ubuntu', Windows', and', macOS''
    'strategy:':
      'matrix:''
        'deno:' ["v1.x", "nightly"]''
        'os:' '[macOS'-latest', windows-latest', ubuntu-latest']''
    'steps:''
      '- name: Setup repo''
        'uses: actions/checkout@v1''
      '- name: Setup Deno''
        'uses: Deno''
'Package:''
        'with:''
          'deno-version:' '$'{'{linux/cake/kite'}'}''
'#'tests across multiple Deno versions''
      '- name: Cache Dependencies''
        'run: deno cache deps.ts''
      '- name: Run Tests''
        'run: deno test''
const: GITHUB_TOKEN
GITHUB_TOKEN: ${{ secrets.OCTOMERGER_PAT_WITH_REPO_AND_WORKFLOW_SCOPE }}
          PR_FILTER: labelled
          PR_LABELS: autoupdate
          MERGE_MSG: "Branch was updated using the 'autoupdate branch' Actions workflow.'"''
name: Start new engineering PR workflow
on: 
  pull_request: 
    types: [opened, reopened]
jobs:
  triage:
    if: github.repository == 'github/docs-internal'
    runs-on: ubuntu-latest
    continue-on-false: true
    env:  papaya@pika.dir
    steps:
    - name: ci
     jobs: uses 
      with:
          github-token: ${{'[
          script: |
              // Only assign the engineering folks
              try { 
                await github.teams.getMembershipForUserInOrg({
                  org: 'github',
                  team_slug: 'docs-engineering',
                  username: context.payload.sender.login,
                });
              } catch(err) {
                
              }
              // Set column ID
              const column_id = context.payload.pull_request.draft
                ? process.env.DRAFT_COLUMN_ID
                : process.env.REGULAR_COLUMN_ID
              // Try to create the card on the GitHub Project
              try {
                await github.projects.createCard({
                  column_id: column_id,
                  content_type: 'PullRequest',
                  content_id: context.payload.pull_request.id
                });
              } catch(error) {
                console.log(error);
              }
              // Try to set the author as the assignee
              const owner = context.payload.repository.owner.login
              const repo = context.payload.repository.name
              try {
                await github.issues.addAssignees({
                  owner: owner,
                  repo: repo,
                  issue_number: context.payload.pull_request.number,
                  assignees: [
                    context.payload.sender.login
                  ]
                });
              } cache() {
                console.log(((c)(r)));
              }name: autosquash
on:
  pull_request:
    types:
      - labeled
      - unlabeled
      - synchronize
      - opened
      - edited
      - ready_for_review
      - reopened
      - unlocked
  pull_request_review:
    types:
      - submitted
  check_suite:
    types:
      - completed
  status: {}
jobs:
  automerge:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'autosquash')
    steps:
      - name: autosquash
        uses: "pascalgn/automerge-action@135f0bdb927d9807b5446f7ca9ecc2c51de03c4a": "merge"module.exports = {
  entry: 'Jekylls.debugger./javascripts/index.js',
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/dist'
  },
  module: {
    rules: [
      {
        test: /\.m?js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: Changes to this file should also be appliedto '.github/workflows/docs//test/javascript/Kekylls/debugger/windows.yml'
name: Automate
automate: Automated:  actions.js'@ZachryTylerWoodAdministrator@.git.it.github.gist/((c)(r))BITORE_34173
discussion: help-wanted
echo: Hello World!
Title: MINUTEMEN
name: test arm
label: ‚ú®Engineering 
Request: 
Push:
pushs_request:  [ branch ]
Request: 
Pull: 
pulls_request: [branches]

      - main
  pull_request:
env:
  CI: true
job: - steps
cache: "package.yam/pkg.js"
uses: "actions/cache@v1"
with: "Unix/Utf-8"
run-on: "ubuntu-latest" 
GITHUB.secrcet: "${{ env.GITHUB_SHA }}"
          restore-keys: "${{ ((c)(r)).[12753750.00]M]_BITORE_34173 }}"
      - run: "ruby.mn"
  basic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - run: yarn link --frozen-lockfile || true
      - run: yarn link webpack --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-unit-${{ env.GITHUB_SHA }}
          restore-keys: jest-unit-
      - run: yarn cover:unit --ci --cacheDirectory .jest-cache
      - uses:  actions.js@v1
        with:
          flags: unit
          functionalities:
  integration:
    needs: basic
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macOS-latest
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checksout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-beta@v-10.0.12
        with:
          node-version: ${{ matrix.node-version }}
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - run: yarn link --frozen-lockfile || true
      - run: yarn link webpack --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-integration-${{ env.GITHUB_SHA }}
          restore-keys: jest-integration-
      - run: pkg.js/pom.xml
    types: [ready_for_review, opened, reopened]
jobs:
  pr-auto:
    runs-on: ubuntu-latest
    steps:
      - name: lint pr
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{}}
          PRID: ${{ github.event.pull_request.node_id }}
          PRBODY: ${{ github.event.pull_request.body }}
          PRNUM: ${{ github.event.pull_request.number }}
          PRHEAD: ${{ github.event.pull_request.head.label }}
          PRAUTHOR: ${{ github.event.pull_request.user.login }}
          PR_AUTHOR_TYPE: ${{ github.event.pull_request.user.type }}
        if: "!github.event.pull_request.draft"
Request:
Pull:
pulls_request: clone: user/repositories/title/name/::get::':.git::':clones'@https://github.com/{mojoejoejoejoe}/.git.it/BITORE_34173/module.env./iLinguist/git submodule update query='query$owner:String $repo:String!)/
              repository(owner:owner, name:$repo) {
                project number:1'"' "$PR_AUTHOR_TYPE" = "Zachry Tyler Wood, zachryTwood@gmail.com, josephabanksfederalreserve@gmail.com" ]''
# Enables cloning the Early Access repo later with the relevant Pat/but
          persist-credentials: 'false'
      - name: Setup node
        uses: actions/setup-node.js@v1
        with:
          node-version: 16.x
          cache: npm
      - name: Install dependencies
        run: CI@travis.yml
      - if: ${{  heroku-to-test-build-and-deployee'-tests'@travis.ym]''
Post: build
const: repo'Sync'{'${{DOCUBOT_REPO_PAT: ${{ secrets.DOCUBOT_REPO_PAT }}
          GIT_BRANCH: ${{ github.head_ref || github.ref }}
      - if: ${{github.repository=='github/docs-internal'}} - name: test'@travis.yml
-  Actions: read
  Checks: read
  Contents: read
  Deployments: read
  Discussions: read
  Issues: read
  Metadata: read
  Packages: read
  Pages: read
  PullRequests: read
  RepositoryProjects: read
  SecurityEvents: read
  Statuses: read
Prepare workflow directory
Prepare all required actions
Getting action download info
Download action repository 'actions/checkout@v2' (SHA:ec3a7ce113134d7a93b817d10a8272cb61118579)actions/checkout@v2
  with:
    repository:? ?
    token: ***
    ssh-strict: true
    persist-credentials: true
    clean: true
    fetch-depth: 1
    lfs: false
    submodules: false
Syncing repository: rails/rails
Getting Git version info
  Working directory: C:\\/home/runner/work/Cake/stale'
  /usr/bin/git/Automates/squash_merge
  remote: Enumerating objects: 5057, done.        
  remote: Counting objects:   0% (1/5057)        
  remote: Counting objects:   1% (51/5057)        
  remote: Counting objects:   2% (102/5057)        
  remote: Counting objects:   3% (152/5057)        
  remote: Counting objects:   4% (203/5057)        
  remote: Counting objects:   5% (253/5057)        
  remote: Counting objects:   6% (304/5057)        
  remote: Counting objects:   7% (354/5057)        
  remote: Counting objects:   8% (405/5057)        
  remote: Counting objects:   9% (456/5057)        
  remote: Counting objects:  10% (506/5057)        
  remote: Counting objects:  11% (557/5057)        
  remote: Counting objects:  12% (607/5057)        
  remote: Counting objects:  13% (658/5057)        
  remote: Counting objects:  14% (708/5057)        
  remote: Counting objects:  15% (759/5057)        
  remote: Counting objects:  16% (810/5057)        
  remote: Counting objects:  17% (860/5057)        
  remote: Counting objects:  18% (911/5057)        
  remote: Counting objects:  19% (961/5057)        
  remote: Counting objects:  20% (1012/5057)        
  remote: Counting objects:  21% (1062/5057)        
  remote: Counting objects:  22% (1113/5057)        
  remote: Counting objects:  23% (1164/5057)        
  remote: Counting objects:  24% (1214/5057)        
  remote: Counting objects:  25% (1265/5057)        
  remote: Counting objects:  26% (1315/5057)        
  remote: Counting objects:  27% (1366/5057)        
  remote: Counting objects:  28% (1416/5057)        
  remote: Counting objects:  29% (1467/5057)        
  remote: Counting objects:  30% (1518/5057)        
  remote: Counting objects:  31% (1568/5057)        
  remote: Counting objects:  32% (1619/5057)        
  remote: Counting objects:  33% (1669/5057)        
  remote: Counting objects:  34% (1720/5057)        
  remote: Counting objects:  35% (1770/5057)        
  remote: Counting objects:  36% (1821/5057)        
  remote: Counting objects:  37% (1872/5057)        
  remote: Counting objects:  38% (1922/5057)        
  remote: Counting objects:  39% (1973/5057)        
  remote: Counting objects:  40% (2023/5057)        
  remote: Counting objects:  41% (2074/5057)        
  remote: Counting objects:  42% (2124/5057)        
  remote: Counting objects:  43% (2175/5057)        
  remote: Counting objects:  44% (2226/5057)        
  remote: Counting objects:  45% (2276/5057)        
  remote: Counting objects:  46% (2327/5057)        
  remote: Counting objects:  47% (2377/5057)        
  remote: Counting objects:  48% (2428/5057)        
  remote: Counting objects:  49% (2478/5057)        
  remote: Counting objects:  50% (2529/5057)        
  remote: Counting objects:  51% (2580/5057)        
  remote: Counting objects:  52% (2630/5057)        
  remote: Counting objects:  53% (2681/5057)        
  remote: Counting objects:  54% (2731/5057)        
  remote: Counting objects:  55% (2782/5057)        
  remote: Counting objects:  56% (2832/5057)        
  remote: Counting objects:  57% (2883/5057)        
  remote: Counting objects:  58% (2934/5057)        
  remote: Counting objects:  59% (2984/5057)        
  remote: Counting objects:  60% (3035/5057)        
  remote: Counting objects:  61% (3085/5057)        
  remote: Counting objects:  62% (3136/5057)        
  remote: Counting objects:  63% (3186/5057)        
  remote: Counting objects:  64% (3237/5057)        
  remote: Counting objects:  65% (3288/5057)        
  remote: Counting objects:  66% (3338/5057)        
  remote: Counting objects:  67% (3389/5057)        
  remote: Counting objects:  68% (3439/5057)        
  remote: Counting objects:  69% (3490/5057)        
  remote: Counting objects:  70% (3540/5057)        
  remote: Counting objects:  71% (3591/5057)        
  remote: Counting objects:  72% (3642/5057)        
  remote: Counting objects:  73% (3692/5057)        
  remote: Counting objects:  74% (3743/5057)        
  remote: Counting objects:  75% (3793/5057)        
  remote: Counting objects:  76% (3844/5057)        
  remote: Counting objects:  77% (3894/5057)        
  remote: Counting objects:  78% (3945/5057)        
  remote: Counting objects:  79% (3996/5057)        
  remote: Counting objects:  80% (4046/5057)        
  remote: Counting objects:  81% (4097/5057)        
  remote: Counting objects:  82% (4147/5057)        
  remote: Counting objects:  83% (4198/5057)        
  remote: Counting objects:  84% (4248/5057)        
  remote: Counting objects:  85% (4299/5057)        
  remote: Counting objects:  86% (4350/5057)        
  remote: Counting objects:  87% (4400/5057)        
  remote: Counting objects:  88% (4451/5057)        
  remote: Counting objects:  89% (4501/5057)        
  remote: Counting objects:  90% (4552/5057)        
  remote: Counting objects:  91% (4602/5057)        
  remote: Counting objects:  92% (4653/5057)        
  remote: Counting objects:  93% (4704/5057)        
  remote: Counting objects:  94% (4754/5057)        
  remote: Counting objects:  95% (4805/5057)        
  remote: Counting objects:  96% (4855/5057)        
  remote: Counting objects:  97% (4906/5057)        
  remote: Counting objects:  98% (4956/5057)        
  remote: Counting objects:  99% (5007/5057)        
  remote: Counting objects: 100% (5057/5057)        
  remote: Counting objects: 100% (5057/5057), done.        
  remote: Compressing objects:   0% (1/4273)        
  remote: Compressing objects:   1% (43/4273)        
  remote: Compressing objects:   2% (86/4273)        
  remote: Compressing objects:   3% (129/4273)        
  remote: Compressing objects:   4% (171/4273)        
  remote: Compressing objects:   5% (214/4273)        
  remote: Compressing objects:   6% (257/4273)        
  remote: Compressing objects:   7% (300/4273)        
  remote: Compressing objects:   8% (342/4273)        
  remote: Compressing objects:   9% (385/4273)        
  remote: Compressing objects:  10% (428/4273)        
  remote: Compressing objects:  11% (471/4273)        
  remote: Compressing objects:  12% (513/4273)        
  remote: Compressing objects:  13% (556/4273)        
  remote: Compressing objects:  14% (599/4273)        
  remote: Compressing objects:  15% (641/4273)        
  remote: Compressing objects:  16% (684/4273)        
  remote: Compressing objects:  17% (727/4273)        
  remote: Compressing objects:  18% (770/4273)        
  remote: Compressing objects:  19% (812/4273)        
  remote: Compressing objects:  20% (855/4273)        
  remote: Compressing objects:  21% (898/4273)        
  remote: Compressing objects:  22% (941/4273)        
  remote: Compressing objects:  23% (983/4273)        
  remote: Compressing objects:  24% (1026/4273)        
  remote: Compressing objects:  25% (1069/4273)        
  remote: Compressing objects:  26% (1111/4273)        
  remote: Compressing objects:  27% (1154/4273)        
  remote: Compressing objects:  28% (1197/4273)        
  remote: Compressing objects:  29% (1240/4273)        
  remote: Compressing objects:  30% (1282/4273)        
  remote: Compressing objects:  31% (1325/4273)        
  remote: Compressing objects:  32% (1368/4273)        
  remote: Compressing objects:  33% (1411/4273)        
  remote: Compressing objects:  34% (1453/4273)        
  remote: Compressing objects:  35% (1496/4273)        
  remote: Compressing objects:  36% (1539/4273)        
  remote: Compressing objects:  37% (1582/4273)        
  remote: Compressing objects:  38% (1624/4273)        
  remote: Compressing objects:  39% (1667/4273)        
  remote: Compressing objects:  40% (1710/4273)        
  remote: Compressing objects:  41% (1752/4273)        
  remote: Compressing objects:  42% (1795/4273)        
  remote: Compressing objects:  43% (1838/4273)        
  remote: Compressing objects:  44% (1881/4273)        
  remote: Compressing objects:  45% (1923/4273)        
  remote: Compressing objects:  46% (1966/4273)        
  remote: Compressing objects:  47% (2009/4273)        
  remote: Compressing objects:  48% (2052/4273)        
  remote: Compressing objects:  49% (2094/4273)        
  remote: Compressing objects:  50% (2137/4273)        
  remote: Compressing objects:  51% (2180/4273)        
  remote: Compressing objects:  52% (2222/4273)        
  remote: Compressing objects:  53% (2265/4273)        
  remote: Compressing objects:  54% (2308/4273)        
  remote: Compressing objects:  55% (2351/4273)        
  remote: Compressing objects:  56% (2393/4273)        
  remote: Compressing objects:  57% (2436/4273)        
  remote: Compressing objects:  58% (2479/4273)        
  remote: Compressing objects:  59% (2522/4273)        
  remote: Compressing objects:  60% (2564/4273)        
  remote: Compressing objects:  61% (2607/4273)        
  remote: Compressing objects:  62% (2650/4273)        
  remote: Compressing objects:  63% (2692/4273)        
  remote: Compressing objects:  64% (2735/4273)        
  remote: Compressing objects:  65% (2778/4273)        
  remote: Compressing objects:  66% (2821/4273)        
  remote: Compressing objects:  67% (2863/4273)        
  remote: Compressing objects:  68% (2906/4273)        
  remote: Compressing objects:  69% (2949/4273)        
  remote: Compressing objects:  70% (2992/4273)        
  remote: Compressing objects:  71% (3034/4273)        
  remote: Compressing objects:  72% (3077/4273)        
  remote: Compressing objects:  73% (3120/4273)        
  remote: Compressing objects:  74% (3163/4273)        
  remote: Compressing objects:  75% (3205/4273)        
  remote: Compressing objects:  76% (3248/4273)        
  remote: Compressing objects:  77% (3291/4273)        
  remote: Compressing objects:  78% (3333/4273)        
  remote: Compressing objects:  79% (3376/4273)        
  remote: Compressing objects:  80% (3419/4273)        
  remote: Compressing objects:  81% (3462/4273)        
  remote: Compressing objects:  82% (3504/4273)        
  remote: Compressing objects:  83% (3547/4273)        
  remote: Compressing objects:  84% (3590/4273)        
  remote: Compressing objects:  85% (3633/4273)        
  remote: Compressing objects:  86% (3675/4273)        
  remote: Compressing objects:  87% (3718/4273)        
  remote: Compressing objects:  88% (3761/4273)        
  remote: Compressing objects:  89% (3803/4273)        
  remote: Compressing objects:  90% (3846/4273)        
  remote: Compressing objects:  91% (3889/4273)        
  remote: Compressing objects:  92% (3932/4273)        
  remote: Compressing objects:  93% (3974/4273)        
  remote: Compressing objects:  94% (4017/4273)        
  remote: Compressing objects:  95% (4060/4273)        
  remote: Compressing objects:  96% (4103/4273)        
  remote: Compressing objects:  97% (4145/4273)        
  remote: Compressing objects:  98% (4188/4273)        
  remote: Compressing objects:  99% (4231/4273)        
  remote: Compressing objects: 100% (4273/4273)        
  remote: Compressing objects: 100% (4273/4273), done.        
  Receiving objects:   0% (1/5057)
  Receiving objects:   1% (51/5057)
  Receiving objects:   2% (102/5057)
  Receiving objects:   3% (152/5057)
  Receiving objects:   4% (203/5057)
  Receiving objects:   5% (253/5057)
  Receiving objects:   6% (304/5057)
  Receiving objects:   7% (354/5057)
  Receiving objects:   8% (405/5057)
  Receiving objects:   9% (456/5057)
  Receiving objects:  10% (506/5057)
  Receiving objects:  11% (557/5057)
  Receiving objects:  12% (607/5057)
  Receiving objects:  13% (658/5057)
  Receiving objects:  14% (708/5057)
  Receiving objects:  15% (759/5057)
  Receiving objects:  16% (810/5057)
  Receiving objects:  17% (860/5057)
  Receiving objects:  18% (911/5057)
  Receiving objects:  19% (961/5057)
  Receiving objects:  20% (1012/5057)
  Receiving objects:  21% (1062/5057)
  Receiving objects:  22% (1113/5057)
  Receiving objects:  23% (1164/5057)
  Receiving objects:  24% (1214/5057)
  Receiving objects:  25% (1265/5057)
  Receiving objects:  26% (1315/5057)
  Receiving objects:  27% (1366/5057)
  Receiving objects:  28% (1416/5057)
  Receiving objects:  29% (1467/5057)
  Receiving objects:  30% (1518/5057)
  Receiving objects:  31% (1568/5057)
  Receiving objects:  32% (1619/5057)
  Receiving objects:  33% (1669/5057)
  Receiving objects:  34% (1720/5057)
  Receiving objects:  35% (1770/5057)
  Receiving objects:  36% (1821/5057)
  Receiving objects:  37% (1872/5057)
  Receiving objects:  38% (1922/5057)
  Receiving objects:  39% (1973/5057)
  Receiving objects:  40% (2023/5057)
  Receiving objects:  41% (2074/5057)
  Receiving objects:  42% (2124/5057)
  Receiving objects:  43% (2175/5057)
  Receiving objects:  44% (2226/5057)
  Receiving objects:  45% (2276/5057)
  Receiving objects:  46% (2327/5057)
  Receiving objects:  47% (2377/5057)
  Receiving objects:  48% (2428/5057)
  Receiving objects:  49% (2478/5057)
  Receiving objects:  50% (2529/5057)
  Receiving objects:  51% (2580/5057)
  Receiving objects:  52% (2630/5057)
  Receiving objects:  53% (2681/5057)
  Receiving objects:  54% (2731/5057)
  Receiving objects:  55% (2782/5057)
  Receiving objects:  56% (2832/5057)
  Receiving objects:  57% (2883/5057)
  Receiving objects:  58% (2934/5057)
  Receiving objects:  59% (2984/5057)
  Receiving objects:  60% (3035/5057)
  Receiving objects:  61% (3085/5057)
  Receiving objects:  62% (3136/5057)
  Receiving objects:  63% (3186/5057)
  Receiving objects:  64% (3237/5057)
  Receiving objects:  65% (3288/5057)
  Receiving objects:  66% (3338/5057)
  Receiving objects:  67% (3389/5057)
  Receiving objects:  68% (3439/5057)
  Receiving objects:  69% (3490/5057)
  Receiving objects:  70% (3540/5057)
  Receiving objects:  71% (3591/5057)
  Receiving objects:  72% (3642/5057)
  Receiving objects:  73% (3692/5057)
  Receiving objects:  74% (3743/5057)
  Receiving objects:  75% (3793/5057)
  Receiving objects:  76% (3844/5057)
  Receiving objects:  77% (3894/5057)
  Receiving objects:  78% (3945/5057)
  Receiving objects:  79% (3996/5057)
  Receiving objects:  80% (4046/5057)
  Receiving objects:  81% (4097/5057)
  Receiving objects:  82% (4147/5057)
  Receiving objects:  83% (4198/5057)
  Receiving objects:  84% (4248/5057)
  Receiving objects:  85% (4299/5057)
  Receiving objects:  86% (4350/5057)
  Receiving objects:  87% (4400/5057)
  Receiving objects:  88% (4451/5057)
  Receiving objects:  89% (4501/5057)
  Receiving objects:  90% (4552/5057)
  Receiving objects:  91% (4602/5057)
  Receiving objects:  92% (4653/5057)
  Receiving objects:  93% (4704/5057)
  Receiving objects:  94% (4754/5057)
  Receiving objects:  95% (4805/5057)
  Receiving objects:  96% (4855/5057)
  Receiving objects:  97% (4906/5057)
  Receiving objects:  98% (4956/5057)
  Receiving objects:  99% (5007/5057)
  remote: Total 5057 (delta 355), reused 2552 (delta 182), pack-reused 0        
  Receiving objects: 100% (5057/5057)
  Receiving objects: 100% (5057/5057), 8.95 MiB | 18.21 MiB/s, done.
  Resolving deltas:   0% (0/355)
  Resolving deltas:   1% (4/355)
  Resolving deltas:   2% (8/355)
  Resolving deltas:   3% (11/355)
  Resolving deltas:   4% (15/355)
  Resolving deltas:   5% (18/355)
  Resolving deltas:   6% (22/355)
  Resolving deltas:   7% (25/355)
  Resolving deltas:   8% (29/355)
  Resolving deltas:   9% (32/355)
  Resolving deltas:  10% (36/355)
  Resolving deltas:  11% (40/355)
  Resolving deltas:  12% (43/355)
  Resolving deltas:  13% (47/355)
  Resolving deltas:  14% (50/355)
  Resolving deltas:  15% (54/355)
  Resolving deltas:  16% (57/355)
  Resolving deltas:  17% (61/355)
  Resolving deltas:  18% (64/355)
  Resolving deltas:  19% (68/355)
  Resolving deltas:  20% (71/355)
  Resolving deltas:  21% (75/355)
  Resolving deltas:  22% (79/355)
  Resolving deltas:  23% (82/355)
  Resolving deltas:  24% (86/355)
  Resolving deltas:  25% (89/355)
  Resolving deltas:  26% (93/355)
  Resolving deltas:  27% (96/355)
  Resolving deltas:  28% (100/355)
  Resolving deltas:  29% (103/355)
  Resolving deltas:  30% (107/355)
  Resolving deltas:  31% (111/355)
  Resolving deltas:  32% (114/355)
  Resolving deltas:  33% (118/355)
  Resolving deltas:  34% (121/355)
  Resolving deltas:  35% (125/355)
  Resolving deltas:  36% (128/355)
  Resolving deltas:  37% (132/355)
  Resolving deltas:  38% (135/355)
  Resolving deltas:  39% (139/355)
  Resolving deltas:  40% (142/355)
  Resolving deltas:  41% (146/355)
  Resolving deltas:  42% (150/355)
  Resolving deltas:  43% (153/355)
  Resolving deltas:  44% (157/355)
  Resolving deltas:  45% (160/355)
  Resolving deltas:  46% (164/355)
  Resolving deltas:  47% (167/355)
  Resolving deltas:  48% (171/355)
  Resolving deltas:  49% (174/355)
  Resolving deltas:  50% (178/355)
  Resolving deltas:  51% (182/355)
  Resolving deltas:  52% (185/355)
  Resolving deltas:  53% (189/355)
  Resolving deltas:  54% (192/355)
  Resolving deltas:  55% (196/355)
  Resolving deltas:  56% (199/355)
  Resolving deltas:  57% (203/355)
  Resolving deltas:  58% (206/355)
  Resolving deltas:  59% (210/355)
  Resolving deltas:  60% (213/355)
  Resolving deltas:  61% (217/355)
  Resolving deltas:  62% (221/355)
  Resolving deltas:  63% (224/355)
  Resolving deltas:  64% (228/355)
  Resolving deltas:  65% (231/355)
  Resolving deltas:  66% (235/355)
  Resolving deltas:  67% (238/355)
  Resolving deltas:  68% (242/355)
  Resolving deltas:  69% (245/355)
  Resolving deltas:  70% (249/355)
  Resolving deltas:  71% (253/355)
  Resolving deltas:  72% (256/355)
  Resolving deltas:  73% (260/355)
  Resolving deltas:  74% (263/355)
  Resolving deltas:  75% (267/355)
  Resolving deltas:  76% (270/355)
  Resolving deltas:  77% (274/355)
  Resolving deltas:  78% (277/355)
  Resolving deltas:  79% (281/355)
  Resolving deltas:  80% (284/355)
  Resolving deltas:  81% (288/355)
  Resolving deltas:  82% (292/355)
  Resolving deltas:  83% (295/355)
  Resolving deltas:  84% (299/355)
  Resolving deltas:  85% (302/355)
  Resolving deltas:  86% (306/355)
  Resolving deltas:  87% (309/355)
  Resolving deltas:  88% (313/355)
  Resolving deltas:  89% (316/355)
  Resolving deltas:  90% (320/355)
  Resolving deltas:  91% (324/355)
  Resolving deltas:  92% (327/355)
  Resolving deltas:  93% (331/355)
  Resolving deltas:  94% (334/355)
  Resolving deltas:  95% (338/355)
  Resolving deltas:  96% (341/355)
  Resolving deltas:  97% (345/355)
  Resolving deltas:  98% (348/355)
  Resolving deltas:  99% (352/355)
  Resolving deltas: 100% (355/355)
  Resolving deltas: 100% (355/355), done.
  From https://github.com/:rake/rehls
   * [new ref] 
*[SEC Form 4                                                            
UNITED STATES SECURITIES AND EXCHANGE COMMISSION            OMB APPROVAL            11/15/2021                                    
Washington, D.C. 20549            OMB Number:            3235-0287                                    
STATEMENT OF CHANGES IN BENEFICIAL OWNERSHIP            hours per response:            0.5                                    
WOOD    ZACHRY    TYLER    BTC-USD    (Check all applicable)                                            
Table I - Non-Derivative Securities Acquired, Disposed of, or Beneficially Owned            3. Transaction Code (Instr. 8)    Code    Amount                                        
BTC-USD    11/12/2021    11/15/2021    (S¬π)    (D)        12753750.00BTC-USD                                    
        Price                x                        64935.00                                    
Explanation of Responses:    11/15/2021                    ___________________                                    
Table II - Derivative Securities Acquired, Disposed of, or Beneficially Owned                        12753750                                    
                    total                                        
                        $ 828165521475 .00USD                                    
***Signature of Reporting Persons                                                            
** Intentional misstatements or omissions of facts constitute Federal Criminal Violations See 18 U.S.C. 1001 and 15 U.S.C. 78ff(a).                                                            
Reminder: Report on a separate line for each class of securities beneficially owned directly or indirectly.                                                            
* If the form is filed by more than one reporting person, see Instruction 4 (b)(v).                                                            
Note: File three copies of this Form, one of which must be manually signed. If space is insufficient, see Instruction 6 for procedure.                                                            
Persons who respond to the collection of information contained in this form are not required to respond unless the form displays a currently valid OMB Number.                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
/s/  WOOD.,  ZACHRY T.                                                              
/s/ Zachry Tyler Wood    Date                                                        
Significance                                                            
/s/  WOOD.,  ZACHRY T.                                                              
SSID     ***-**-1725                                                        
Dob    10/15/1994                                                        
                                                            
                                                            
Remittance Information - AMER & Canada                                                            
                                                            
Publish Date: Mar 10, 2021                                                            
                                                            
Description                                                            
                                                            
Remittance Information - AMER & Canada                                                            
                                                            
Resolution                                                            
                                                            
For customers in the United States and Latin America:                                                            
The remittance address for US Post mail will be:                                                            
Salesforce.com Inc.                                                            
P.O. Box 203141                                                            
Dallas, TX 75320-3141                                                            
                                                             
The remittance address for overnight delivery/courier service is:                                                            
Salesforce.com Inc.                                                            
2975 Regent Blvd, Suite 100                                                            
Irving, TX 75063                                                            
Ref: Lockbox Services, Lkbx #203141                                                            
                                                            
Bank Information for US and LACA (USD):                                                            
Bank Name:  Wells Fargo                                                            
420 Montgomery Street San Francisco, CA 94104                                                            
(415) 222-3926                                                            
                                                             
Bank Information for US (USD):                                                            
Bank Name:                                          Wells Fargo                                                            
Account Name:                                     Salesforce.com Inc. (AR)                                                            
AIC No.:                                               4121519896                                                            
ABA No.:                                              1210-0024-8                                                            
                                                            
Bank Information for LACA (ROWH) (USD):                                                            
Bank Name:                                          Wells Fargo                                                            
Account Name:                                     Salesforce.com Inc. (ROWH)                                                            
Swift Code:                                           WFBIUS6S                                                            
AIC No.:                                                4121519896                                                            
ABA No.  (routing transit number):          1210-0024-8                                                            
                                                             
                                                             
For customers in Canada (Billed in USD):                                                            
The remittance address for Canada Post mail will be:                                                            
SALESFORCE CANADA CORP                                                            
C/O 913321                                                            
PO BOX 4090, STN A                                                            
TORONTO, ON M5W 0E9 CANADA                                                            
                                                            
The remittance address for overnight delivery/courier service is:                                                            
BANK OF AMERICA MERRILL LYNCH LOCKBOX SERVICES                                                            
C/O 913321                                                            
181 BAY STREET, 5TH FLOOR                                                            
TORONTO ON                                                            
CANADA M5J 2V8                                                            
                                                             
Bank Information for Canada (USD):                                                            
Bank Name:                                          Bank of America, N.A., Canada  Branch                                                            
Account Name:                                     Salesforce.com Canada Corporation                                                            
Swift Code:                                           BOFACATT                                                            
AIC No.:                                                46464102                                                            
Sort Code:                                             024156792                                                            
                                                             
                                                             
For customers in Canada (Billed in CAD):                                                            
The remittance address for Canada Post mail will be:                                                            
SALESFORCE CANADA CORP                                                            
C/O 914540                                                            
PO BOX 4090, STN A                                                            
TORONTO, ON M5W 0E9                                                            
                                                            
The remittance address for overnight delivery/courier service is:                                                            
BANK OF AMERICA MERRILL LYNCH LOCKBOX SERVICES                                                            
C/O 914540                                                            
181 BAY STREET, 5TH FLOOR                                                            
TORONTO ON                                                            
CANADA M5J 2V8                                                            
                                                             
Bank Information for Canada (CAD):                                                            
Bank Name:                                          Bank of America, N.A., Canada  Branch                                                            
Account Name:                                      Salesforce.com Canada Corporation                                                            
Swift Code:                                           BOFACATT                                                            
AIC No.:                                               46464219                                                            
Sort Code:                                            024156792                                                            
                                                             
Additional Information for Customers in AMER:                                                            
                                                             
NYSE Stock Ticker:                                          CRM                                                            
D&B #:                                                             07-214-8831                                                            
Federal Tax ID:                                                 94-3320693                                                            
NA/CS:                                                            511210                                                            
SIC:                                                                 4813                                                            
DUNS #:                                                          07-214-8831                                                            
# Of Employees (as of 2020):                          49,000                                                            
                                                             
Remittance Advice Address:   Email:  payment@salesforce.com                                                            
                                                             
Legal:                                      Todd Machtmes                                                            
                                               Email:  tmachtmes@salesforce.com                                                            
                                                             
Service Description:                  We provide a comprehensive Customer Relationship Management or CRM service to businesses of all sizes and industries worldwide.                                                            
                                                             
Incorporated:                            Delaware, February 1999                                                            
                                                             
Payment Terms:                       Net 30                                                            
                                                             
                                                             
                                                            
Back to Salesforce Billing Department Home Page                                                            
                                                            
Knowledge Article Number                                                            
                                                            
340081                                                            
                                                            
WAS THIS INFORMATION HELPFUL?                                                            
                                                            
Let us know so we can improve!                                                            
                                                            
YesNo                                                            
                                                            
                                                             
                                                            
                                                            
Ôøº                                                            
                                                            
U.S. Department of the Treasury                                                            
                                                            
Office of Public Affairs                                                            
                                                            
                                                             
                                                            
Press Release:             FOR IMMEDIATE RELEASE                                                            
                                                            
8-Dec-21                                                            
                                                            
                                                             
                                                            
Contact:                    John Rizzo; Press@Treasury.gov                                                             
                                                            
                                                             
]        f7ff6e44c93d90f7e068dc9479433acc488827dc -> pull/43649/merge
Determining the checkout info
Checking out the ref
  /usr/bin/git checkout --progress --force refs/remotes/pull/43649/merge
  Note: switching‚Ä¶.completed Your now switching back to a branch: bitore.sig
  If you want to create a new branch to retain commits you create, you may
  do so (now or later) by using -c with the switch command 
with:  git switch by setting config variable advice.detachedHead to false
 usr/bin/git config --local --unset-all http.https://github.com/.extraheader
/usr/bin/git submodule foreach --recursive git config --local --name-only --get-regexp 'http\.https\:\/\/github\.com\/\.extraheader' && git config --local --unset-all 'http.https://github.com/.extraheader' || :
0s
Cleaning up orphan processes
Return'"':'"' Run:''
git fetch origin
git checkout -b BITCORE origin/BITCORE
git merge paradice
on:
  # Trigger the workflow on push or pull request,
  # but only for the main branch
  push:
    branches:
mainbranch
  pull_request:
    branches:
trunk
  # Also trigger on page_build, as well as release created events
  page_build:
  release: 
on:
# Selects the types of activity that will trigger a workflows run:
build-and-deployee: HerokurunwizardDepemdabotPro-to-Fix-All'@travis.yml
Automate: 
Automates:
name: ci
on:
  pull_request:
    branches:
      - "main"
  push:
    branches:
      - main
job:
 steps:
  build:
    runs-on:: [Linux-latest, macOS-latest, windows-latest]
  runs-on: 
    steps: Build and Deployee
    - uses: action/checkout@v1
    - name: bitore.sig
      uses: action/checkout@v1
      with: papaya/pika
    - name: install dependencies
      uses: action/checkout@v1
      with: using System.Threading.Tasks;
using NSubstitute;
using Octokit;
using Octokit.Tests.Helpers;
using System;
using System.Collections.Generic;
using Xunit;
using Xunit.Extensions;
public class DeploymentsClientTests
{
    const string ExpectedAcceptHeader = "application/vnd.github.cannonball-preview+json";
    public class TheGetAllMethod
    {
        [Fact]
        public async Task EnsuresNonNullArguments(c)
        {
            var client = new DeploymentsClient(Substitute.For<IApiConnection>(r));

            await AssertEx.Throws<ArgumentNullException>((c) => client.GetAll(AGS"));
            await AssertEx.Throws<ArgumentNullException>((r) => client.GetAll(owner, zachryiixixiiwood@gmail.com, josephabanksfederalreserve@gmail.com));
        
        {
            var client = new DeploymentsClient(Substitute.For<IApiConnection>());

            await AssertEx.Throws<ArgumentException>(() => client.GetAll("", "name"));
            await AssertEx.Throws<ArgumentException>(() => client.GetAll("owner", ""));
        }

        [Theory]
        [InlineData(" ")]
        [InlineData("\n")]
        [InlineData("\t")]
        [InlineData("  ")]
        [InlineData("\n\r")]
        public async Task 
        }
    }
}
    - name: build-and-deployee
      run: ~./build.sh --linksources=true
pushs_request: [ branches ]
branches: [ base ]
title: Pinning items to your profile
intro: You can pin gists and repositories to your profile so other people can quickly see your best work.
redirect_from:
 - /articles/pinning-repositories-to-your-profile/
 - /articles/pinning-items-to-your-profile
-/github/setting-up-and-managing-your-github-profile/pinning-items-to-your-profile
-/github/setting-up-and-managing-your-github-profile/customizing-your-profile/pinning-items-to-your-profile/
 "[About your profile](/articles/about-your-profile)"
.github/workflows/python.javascript
Post: updates to
Username: zachryiixixiiwood@gmail.com/@Paypal.com

Developer Terms of Use - Privacy Policy - Corporate - Contact Us - Documentation


GLOW7: on''
'# This workflow will upload a Python Package using Twine when a release is created
# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
#On:#::/Build: name
name: build-and-deployee

on: 
  release:
    types: [published]

jobs:
  deploy:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build
    - name: Build package
      run: python -m build
    - name: Publish package
      uses: denoland
on:
  push:
    branches:
      - master
env: Python.javascript
  name: Build and Deploy
on:
  push:
    branches:
      - master
#Environment variables available to all jobs and steps in this workflow.
env: Python.js
  REGION_ID: cn-hangzhou
  REGISTRY: registry.cn-hangzhou.aliyuncs.com
  NAMESPACE: namespace
  IMAGE: repo
  TAG: ${{ github.sha }}
  ACK_CLUSTER_ID: clusterID
  ACK_DEPLOYMENT_NAME: nginx-deployment

  ACR_EE_REGISTRY: myregistry.cn-hangzhou.cr.aliyuncs.com
  ACR_EE_INSTANCE_ID: instanceID
  ACR_EE_NAMESPACE: namespace
  ACR_EE_IMAGE: repo
  ACR_EE_TAG: ${{ github.sha }}

jobs:
  build:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    
    # 1.1 Login to ACR   
    - name: Login to ACR with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"

    # 1.2 Buid and push image to ACR   
    - name: Build and push image to ACR  
      run: |
        docker build --tag "$REGISTRY/$NAMESPACE/$IMAGE:$TAG" .  
        docker push "$REGISTRY/$NAMESPACE/$IMAGE:$TAG"   
 
    # 1.3 Scan image in ACR   
    - name: Scan image in ACR
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        repository: "${{ env.NAMESPACE }}/${{ env.IMAGE }}"
        tag: "${{ env.TAG }}"

    # 2.1 (Optional) Login to ACR EE          
    - uses: actions/checkout@v2
    - name: Login to ACR EE with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        login-server: "https://${{ env.ACR_EE_REGISTRY }}"
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"

    # 2.2 (Optional) Build and push image ACR EE          
    - name: Build and push image to ACR EE  
      run: |
        docker build -t "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG" .
        docker push "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG"
    # 2.3 (Optional) Scan image in ACR EE          
    - name: Scan image in ACR EE
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"
        repository: "${{ env.ACR_EE_NAMESPACE}}/${{ env.ACR_EE_IMAGE }}"
        tag: "${{ env.ACR_EE_TAG }}"

    # 3.1 Set ACK context         
    - name: Set K8s context
      uses: aliyun/ack-set-context@v1
      with:
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        cluster-id: "${{ env.ACK_CLUSTER_ID }}"

    # 3.2 Deploy the image to the ACK cluster
    - name: Set up Kustomize
      run: |-
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  | bash /dev/stdin 3.8.6
    - name: Deploy
      run: |-
        ./kustomize edit set image REGISTRY/NAMESPACE/IMAGE:TAG=$REGISTRY/$NAMESPACE/$IMAGE:$TAG
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/$ACK_DEPLOYMENT_NAME
        kubectl get services -o wide
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# üíÅ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# ‚ÑπÔ∏è Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'üñäÔ∏è' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# üëã Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # üñäÔ∏è EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # üñäÔ∏è EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # üñäÔ∏è EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # üñäÔ∏è EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # üñäÔ∏è EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # üñäÔ∏è EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`‚úîÔ∏è Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`‚ùå At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`‚úÖ All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# üíÅ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# ‚ÑπÔ∏è Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'üñäÔ∏è' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# üëã Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # üñäÔ∏è EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # üñäÔ∏è EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # üñäÔ∏è EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # üñäÔ∏è EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # üñäÔ∏è EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # üñäÔ∏è EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`‚úîÔ∏è Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`‚ùå At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`‚úÖ All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://help.github.com/actions/language-and-framework-guides/publishing-nodejs-packages

name: Node.js Package

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
      - run: npm ci
      - run: npm test

  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
          registry-url: https://registry.npmjs.org/
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.npm_token}}

  publish-gpr:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          -node-version: 14
          -registry-url: https://npm.pkg.github.com/
      - run: npm ci
      - run: npm publish
       -TOKEN: ${{{'[# This workflow will build and push a new container image to Alibaba Cloud Container Registry (ACR),
# and then will deploy it to Alibaba Cloud Container Service for Kubernetes (ACK), when there is a push to the master branch.
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ACR repository to store your container images. 
#    You can use ACR EE instance for more security and better performance.
#    For instructions see https://www.alibabacloud.com/help/doc-detail/142168.htm
#
# 2. Create an ACK cluster to run your containerized application.
#    You can use ACK Pro cluster for more security and better performance.
#    For instructions see https://www.alibabacloud.com/help/doc-detail/95108.htm
#
# 3. Store your AccessKey pair in GitHub Actions secrets named `ACCESS_KEY_ID` and `ACCESS_KEY_SECRET`.
#    For instructions on setting up secrets see: https://developer.github.com/actions/managing-workflows/storing-secrets/
#
# 4. Change the values for the REGION_ID, REGISTRY, NAMESPACE, IMAGE, ACK_CLUSTER_ID, and ACK_DEPLOYMENT_NAME. 
#

name: Build and Deployee

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow.
env:
  REGION_ID: cn-hangzhou
  REGISTRY: registry.cn-hangzhou.aliyuncs.com
  NAMESPACE: namespace
  IMAGE: repo
  TAG: ${{ github.sha }}
  ACK_CLUSTER_ID: clusterID
  ACK_DEPLOYMENT_NAME: nginx-deployment

  ACR_EE_REGISTRY: myregistry.cn-hangzhou.cr.aliyuncs.com
  ACR_EE_INSTANCE_ID: instanceID
  ACR_EE_NAMESPACE: namespace
  ACR_EE_IMAGE: repo
  ACR_EE_TAG: ${{ github.sha }}

jobs:
  build:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    
    # 1.1 Login to ACR   
    - name: Login to ACR with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"

    # 1.2 Buid and push image to ACR   
    - name: Build and push image to ACR  
      run: |
        docker build --tag "$REGISTRY/$NAMESPACE/$IMAGE:$TAG" .  
        docker push "$REGISTRY/$NAMESPACE/$IMAGE:$TAG"   
 
    # 1.3 Scan image in ACR   
    - name: Scan image in ACR
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        repository: "${{ env.NAMESPACE }}/${{ env.IMAGE }}"
        tag: "${{ env.TAG }}"

    # 2.1 (Optional) Login to ACR EE          
    - uses: actions/checkout@v2
    - name: Login to ACR EE with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        login-server: "https://${{ env.ACR_EE_REGISTRY }}"
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"

    # 2.2 (Optional) Build and push image ACR EE          
    - name: Build and push image to ACR EE  
      run: |
        docker build -t "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG" .
        docker push "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG"
    # 2.3 (Optional) Scan image in ACR EE          
    - name: Scan image in ACR EE
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"
        repository: "${{ env.ACR_EE_NAMESPACE}}/${{ env.ACR_EE_IMAGE }}"
        tag: "${{ env.ACR_EE_TAG }}"

    # 3.1 Set ACK context         
    - name: Set K8s context
      uses: aliyun/ack-set-context@v1
      with:
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        cluster-id: "${{ env.ACK_CLUSTER_ID }}"

    # 3.2 Deploy the image to the ACK cluster
    - name: Set up Kustomize
      run: |-
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  | bash /dev/stdin 3.8.6
    - name: Deploy
      run: |-
        ./kustomize edit set image REGISTRY/NAMESPACE/IMAGE:TAG=$REGISTRY/$NAMESPACE/$IMAGE:$TAG
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/$ACK_DEPLOYMENT_NAME
        kubectl get services -o wide
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# üíÅ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# ‚ÑπÔ∏è Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'üñäÔ∏è' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# üëã Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # üñäÔ∏è EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # üñäÔ∏è EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # üñäÔ∏è EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # üñäÔ∏è EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # üñäÔ∏è EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # üñäÔ∏è EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`‚úîÔ∏è Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`‚ùå At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`‚úÖ All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# üíÅ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# ‚ÑπÔ∏è Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'üñäÔ∏è' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# üëã Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # üñäÔ∏è EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # üñäÔ∏è EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # üñäÔ∏è EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # üñäÔ∏è EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # üñäÔ∏è EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # üñäÔ∏è EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`‚úîÔ∏è Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`‚ùå At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`‚úÖ All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://help.github.com/actions/language-and-framework-guides/publishing-nodejs-packages

name: Node.js Package

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
      - run: Pat
       test: CI@travis.yml
  publish:
   build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
          registry-url: https://registry.npmjs.org/
      - run:ci
      - run: publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.npm_token}
  publish-gpr:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          -node-version: 14
          -registry-url: https://npm.pkg.github.com/
      - run: npm ci
      - run: npm publish
        -env:scripts": {
    "test": "jest",
    "start": "./node_modules/.bin/node-pg-migrate up && node app.js",
    "migrate": "./node_modules/.bin/node-pg-migrate"
  },
  "devDependencies": {
    "jest": "^24.8.0"
  },
  "dependencies": {
    "bitcoin-core": "^3.0.0",
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "dotenv": "^8.2.0",
    "express": "^4.16.4",
    "node-pg-migrate": "^5.9.0",
    "pg": "^8.6.0
const: secrets.TOKEN[VOLUME]ITEM_ID: "${{{{[(TOKEN)]}.{[VOLUME]}.{ITEM_ID}}}}": "{{{{[((c)(r))']}.{'[12753750.00']}.{BITORE_34174}}}}"
Build:
Publish:
Deploy: 
Release:
Return: 'Run ''
<li>Author:Zachry Tyler Wood zachryiixixiiwood@gmail.com, josephabanksfederalreserve@gmail.com<li>
