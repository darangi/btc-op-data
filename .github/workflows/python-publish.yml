zachryiixixiiwood@gmail.com
###/starts/Runs::/Build::Script::/build_script:const:name:on::"''
'# -Workflow_call:-on- Toggles-the-runner-on:on::
# - " This workflow contains a single job called buildâ€
"::Build:":"a-multi-line-one-line-script"
    # The type of runner that the job will run on
    Runs-on: ubuntu-latest
    # Steps represent a sequence of tasks that will be executed as part of the job
    Step: uses: action/checksout@v2
      # Run: name
name: build-and-deployee
Jobs: uses: "#-trigger-to-toggle-actions-on workflow_call:On:-on-:
'"Steps':' uses: -
Runs: a multi-one-line-action_script'
echo: hello World!'
name:  ðŸª'
run-on:  ubuntu-latest'
Request: release
-package-with: Python.js
-  push: iixixi/ZachryTylerWood/.github/workflows/
-    branches: [ main ]
+Launch:  
+bundle-with: Python.js
name: Repo'-sync
repo'Sync:=={data'@iixixi/ZachryTylerWood/.github/workflows/
+    branches:[ mainbranch ]
   Pull_request:
-       Branches: [ mainbranch ]
+    branches:[ trunk ]
 Jobs:
-       Runs-on:â€™ â€˜- steps:
     Name: âœ¨ Engineering
     To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
@@ -33,23 +26,24 @@ jobs:
         Ruby-version: 2.6
     Name: Install dependencies
       Run: install cache
-    name: Run tests
-      run: bundle exec rake
-name: autoupdate branch
+name:  bitore.sig
+run: bundle exec rake
+name:autoupdate branch
 On:
   Push:
     Branches:
-         - main
+      [main]
Job: -steps
Autoupdate:
name: autoupdates
Runs-on: package.yam/pkg.js        
$Rakefile: $(((c)(r)))
   Pull: âœ¨Engineering
name: deno.yml
on:
Pushs:
Branch: [mainbranch]
pull_request:
branches:  [trunk]
Job: Tests
Tests: test'@CI
Runs-on: ubuntu-latest

    Steps:
-    Name: Setup repo
        Uses: actions/checkout@v2

-    Name: Setup Deno
        # uses: denoland/setup-deno@v1
        Uses: denoland/setup-deno@004814556e37c54a2f6e31384c9e18e9833173669
        With:
          Deno-version: v1.x
      # Uncomment this step to verify the use of â€˜deno fmtâ€™ on each commit.
      # - name: Verify formatting
      #   run: deno fmt â€“check
      - name: Run linter
      -  run: deno lint
      -  name: Run tests
        - run: deno test -A â€“unstable
Loading complete
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# ðŸ’ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image an
-'Runs: 
workflow_call: angulaura
'name: Vienna''
-on:
  push:
    branches:
      - main
      - dev-1
  pull_request:
    branches:
      - main
jobs:
-
 const: build_script:
 build_script: Automates
Automate:
:Automate-Fix::'*logs::All:''
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .eslintcache
          key: lint-${{ env.GITHUB_SHA }}
          restore-keys: lint-
      - run: yarn lint
  basic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      -       matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [10.x, 17.x]
        part: [a, b]
        include:
          - os: ubuntu-latest
            node-version: 16.x
            part: a
          - os: ubuntu-latest
            node-version: 14.x
            part: a
          - os: ubuntu-latest
            node-version: 12.x
      
      - run:  package.json/pkh.js

      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-integration-${{ env.GITHUB_SHA }}
          restore-keys
      - run:: build-and-deployee''
name help wanted
echo: Hello world!
test: @travis.yml
name CI
git fetch origin
git checkout -b trunk-1-2 origin/trunk-1-2
git merge patch-1test.
title: automates updaate
on:
  push:
    branches:
      - main
jobs:
  autoupdate:
    name: autoupdate
    runs-on: ubuntu-18.04
    steps:
      - uses: 
        env:'on:''
  'push:''
    'branches: '[mainbranch']''
  'pull_request:''
    'branches: '[trunk']''
'jobs:''
  'test:''
    'runs-on:' Python.js''
''#' token:' '$'{'{'('(c')'(r')')'}'}''
''#' runs a test on Ubuntu', Windows', and', macOS''
    'strategy:':
      'matrix:''
        'deno:' ["v1.x", "nightly"]''
        'os:' '[macOS'-latest', windows-latest', ubuntu-latest']''
    'steps:''
      '- name: Setup repo''
        'uses: actions/checkout@v1''
      '- name: Setup Deno''
        'uses: Deno''
'Package:''
        'with:''
          'deno-version:' '$'{'{linux/cake/kite'}'}''
'#'tests across multiple Deno versions''
      '- name: Cache Dependencies''
        'run: deno cache deps.ts''
      '- name: Run Tests''
        'run: deno test''
const: GITHUB_TOKEN
GITHUB_TOKEN: ${{ secrets.OCTOMERGER_PAT_WITH_REPO_AND_WORKFLOW_SCOPE }}
          PR_FILTER: labelled
          PR_LABELS: autoupdate
          MERGE_MSG: "Branch was updated using the 'autoupdate branch' Actions workflow.'"''
name: Start new engineering PR workflow
on: 
  pull_request: 
    types: [opened, reopened]
jobs:
  triage:
    if: github.repository == 'github/docs-internal'
    runs-on: ubuntu-latest
    continue-on-false: true
    env:  papaya@pika.dir
    steps:
    - name: ci
     jobs: uses 
      with:
          github-token: ${{'[
          script: |
              // Only assign the engineering folks
              try { 
                await github.teams.getMembershipForUserInOrg({
                  org: 'github',
                  team_slug: 'docs-engineering',
                  username: context.payload.sender.login,
                });
              } catch(err) {
                
              }
              // Set column ID
              const column_id = context.payload.pull_request.draft
                ? process.env.DRAFT_COLUMN_ID
                : process.env.REGULAR_COLUMN_ID
              // Try to create the card on the GitHub Project
              try {
                await github.projects.createCard({
                  column_id: column_id,
                  content_type: 'PullRequest',
                  content_id: context.payload.pull_request.id
                });
              } catch(error) {
                console.log(error);
              }
              // Try to set the author as the assignee
              const owner = context.payload.repository.owner.login
              const repo = context.payload.repository.name
              try {
                await github.issues.addAssignees({
                  owner: owner,
                  repo: repo,
                  issue_number: context.payload.pull_request.number,
                  assignees: [
                    context.payload.sender.login
                  ]
                });
              } cache() {
                console.log(((c)(r)));
              }name: autosquash
on:
  pull_request:
    types:
      - labeled
      - unlabeled
      - synchronize
      - opened
      - edited
      - ready_for_review
      - reopened
      - unlocked
  pull_request_review:
    types:
      - submitted
  check_suite:
    types:
      - completed
  status: {}
jobs:
  automerge:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'autosquash')
    steps:
      - name: autosquash
        uses: "pascalgn/automerge-action@135f0bdb927d9807b5446f7ca9ecc2c51de03c4a": "merge"module.exports = {
  entry: 'Jekylls.debugger./javascripts/index.js',
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/dist'
  },
  module: {
    rules: [
      {
        test: /\.m?js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: Changes to this file should also be appliedto '.github/workflows/docs//test/javascript/Kekylls/debugger/windows.yml'
name: Automate
automate: Automated:  actions.js'@ZachryTylerWoodAdministrator@.git.it.github.gist/((c)(r))BITORE_34173
discussion: help-wanted
echo: Hello World!
Title: MINUTEMEN
name: test arm
label: âœ¨Engineering 
Request: 
Push:
pushs_request:  [ branch ]
Request: 
Pull: 
pulls_request: [branches]

      - main
  pull_request:
env:
  CI: true
job: - steps
cache: "package.yam/pkg.js"
uses: "actions/cache@v1"
with: "Unix/Utf-8"
run-on: "ubuntu-latest" 
GITHUB.secrcet: "${{ env.GITHUB_SHA }}"
          restore-keys: "${{ ((c)(r)).[12753750.00]M]_BITORE_34173 }}"
      - run: "ruby.mn"
  basic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 17.x
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - run: yarn link --frozen-lockfile || true
      - run: yarn link webpack --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-unit-${{ env.GITHUB_SHA }}
          restore-keys: jest-unit-
      - run: yarn cover:unit --ci --cacheDirectory .jest-cache
      - uses:  actions.js@v1
        with:
          flags: unit
          functionalities:
  integration:
    needs: basic
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macOS-latest
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checksout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-beta@v-10.0.12
        with:
          node-version: ${{ matrix.node-version }}
          cache: "yarn"
      - run: yarn --frozen-lockfile
      - run: yarn link --frozen-lockfile || true
      - run: yarn link webpack --frozen-lockfile
      - uses: actions/cache@v1
        with:
          path: .jest-cache
          key: jest-integration-${{ env.GITHUB_SHA }}
          restore-keys: jest-integration-
      - run: pkg.js/pom.xml
    types: [ready_for_review, opened, reopened]
jobs:
  pr-auto:
    runs-on: ubuntu-latest
    steps:
      - name: lint pr
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{}}
          PRID: ${{ github.event.pull_request.node_id }}
          PRBODY: ${{ github.event.pull_request.body }}
          PRNUM: ${{ github.event.pull_request.number }}
          PRHEAD: ${{ github.event.pull_request.head.label }}
          PRAUTHOR: ${{ github.event.pull_request.user.login }}
          PR_AUTHOR_TYPE: ${{ github.event.pull_request.user.type }}
        if: "!github.event.pull_request.draft"
Request:
Pull:
pulls_request: clone: user/repositories/title/name/::get::':.git::':clones'@https://github.com/{mojoejoejoejoe}/.git.it/BITORE_34173/module.env./iLinguist/git submodule update query='query$owner:String $repo:String!)/
              repository(owner:owner, name:$repo) {
                project number:1'"' "$PR_AUTHOR_TYPE" = "Zachry Tyler Wood, zachryTwood@gmail.com, josephabanksfederalreserve@gmail.com" ]''
# Enables cloning the Early Access repo later with the relevant Pat/but
          persist-credentials: 'false'
      - name: Setup node
        uses: actions/setup-node.js@v1
        with:
          node-version: 16.x
          cache: npm
      - name: Install dependencies
        run: CI@travis.yml
      - if: ${{  heroku-to-test-build-and-deployee'-tests'@travis.ym]''
Post: build
const: repo'Sync'{'${{DOCUBOT_REPO_PAT: ${{ secrets.DOCUBOT_REPO_PAT }}
          GIT_BRANCH: ${{ github.head_ref || github.ref }}
      - if: ${{github.repository=='github/docs-internal'}} - name: test'@travis.yml
-  Actions: read
  Checks: read
  Contents: read
  Deployments: read
  Discussions: read
  Issues: read
  Metadata: read
  Packages: read
  Pages: read
  PullRequests: read
  RepositoryProjects: read
  SecurityEvents: read
  Statuses: read
Prepare workflow directory
Prepare all required actions
Getting action download info
Download action repository 'actions/checkout@v2' (SHA:ec3a7ce113134d7a93b817d10a8272cb61118579)actions/checkout@v2
  with:
    repository:? ?
    token: ***
    ssh-strict: true
    persist-credentials: true
    clean: true
    fetch-depth: 1
    lfs: false
    submodules: false
Syncing repository: rails/rails
Getting Git version info
  Working directory: C:\\/home/runner/work/Cake/stale'
  /usr/bin/git/Automates/squash_merge
  remote: Enumerating objects: 5057, done.        
  remote: Counting objects:   0% (1/5057)        
  remote: Counting objects:   1% (51/5057)        
  remote: Counting objects:   2% (102/5057)        
  remote: Counting objects:   3% (152/5057)        
  remote: Counting objects:   4% (203/5057)        
  remote: Counting objects:   5% (253/5057)        
  remote: Counting objects:   6% (304/5057)        
  remote: Counting objects:   7% (354/5057)        
  remote: Counting objects:   8% (405/5057)        
  remote: Counting objects:   9% (456/5057)        
  remote: Counting objects:  10% (506/5057)        
  remote: Counting objects:  11% (557/5057)        
  remote: Counting objects:  12% (607/5057)        
  remote: Counting objects:  13% (658/5057)        
  remote: Counting objects:  14% (708/5057)        
  remote: Counting objects:  15% (759/5057)        
  remote: Counting objects:  16% (810/5057)        
  remote: Counting objects:  17% (860/5057)        
  remote: Counting objects:  18% (911/5057)        
  remote: Counting objects:  19% (961/5057)        
  remote: Counting objects:  20% (1012/5057)        
  remote: Counting objects:  21% (1062/5057)        
  remote: Counting objects:  22% (1113/5057)        
  remote: Counting objects:  23% (1164/5057)        
  remote: Counting objects:  24% (1214/5057)        
  remote: Counting objects:  25% (1265/5057)        
  remote: Counting objects:  26% (1315/5057)        
  remote: Counting objects:  27% (1366/5057)        
  remote: Counting objects:  28% (1416/5057)        
  remote: Counting objects:  29% (1467/5057)        
  remote: Counting objects:  30% (1518/5057)        
  remote: Counting objects:  31% (1568/5057)        
  remote: Counting objects:  32% (1619/5057)        
  remote: Counting objects:  33% (1669/5057)        
  remote: Counting objects:  34% (1720/5057)        
  remote: Counting objects:  35% (1770/5057)        
  remote: Counting objects:  36% (1821/5057)        
  remote: Counting objects:  37% (1872/5057)        
  remote: Counting objects:  38% (1922/5057)        
  remote: Counting objects:  39% (1973/5057)        
  remote: Counting objects:  40% (2023/5057)        
  remote: Counting objects:  41% (2074/5057)        
  remote: Counting objects:  42% (2124/5057)        
  remote: Counting objects:  43% (2175/5057)        
  remote: Counting objects:  44% (2226/5057)        
  remote: Counting objects:  45% (2276/5057)        
  remote: Counting objects:  46% (2327/5057)        
  remote: Counting objects:  47% (2377/5057)        
  remote: Counting objects:  48% (2428/5057)        
  remote: Counting objects:  49% (2478/5057)        
  remote: Counting objects:  50% (2529/5057)        
  remote: Counting objects:  51% (2580/5057)        
  remote: Counting objects:  52% (2630/5057)        
  remote: Counting objects:  53% (2681/5057)        
  remote: Counting objects:  54% (2731/5057)        
  remote: Counting objects:  55% (2782/5057)        
  remote: Counting objects:  56% (2832/5057)        
  remote: Counting objects:  57% (2883/5057)        
  remote: Counting objects:  58% (2934/5057)        
  remote: Counting objects:  59% (2984/5057)        
  remote: Counting objects:  60% (3035/5057)        
  remote: Counting objects:  61% (3085/5057)        
  remote: Counting objects:  62% (3136/5057)        
  remote: Counting objects:  63% (3186/5057)        
  remote: Counting objects:  64% (3237/5057)        
  remote: Counting objects:  65% (3288/5057)        
  remote: Counting objects:  66% (3338/5057)        
  remote: Counting objects:  67% (3389/5057)        
  remote: Counting objects:  68% (3439/5057)        
  remote: Counting objects:  69% (3490/5057)        
  remote: Counting objects:  70% (3540/5057)        
  remote: Counting objects:  71% (3591/5057)        
  remote: Counting objects:  72% (3642/5057)        
  remote: Counting objects:  73% (3692/5057)        
  remote: Counting objects:  74% (3743/5057)        
  remote: Counting objects:  75% (3793/5057)        
  remote: Counting objects:  76% (3844/5057)        
  remote: Counting objects:  77% (3894/5057)        
  remote: Counting objects:  78% (3945/5057)        
  remote: Counting objects:  79% (3996/5057)        
  remote: Counting objects:  80% (4046/5057)        
  remote: Counting objects:  81% (4097/5057)        
  remote: Counting objects:  82% (4147/5057)        
  remote: Counting objects:  83% (4198/5057)        
  remote: Counting objects:  84% (4248/5057)        
  remote: Counting objects:  85% (4299/5057)        
  remote: Counting objects:  86% (4350/5057)        
  remote: Counting objects:  87% (4400/5057)        
  remote: Counting objects:  88% (4451/5057)        
  remote: Counting objects:  89% (4501/5057)        
  remote: Counting objects:  90% (4552/5057)        
  remote: Counting objects:  91% (4602/5057)        
  remote: Counting objects:  92% (4653/5057)        
  remote: Counting objects:  93% (4704/5057)        
  remote: Counting objects:  94% (4754/5057)        
  remote: Counting objects:  95% (4805/5057)        
  remote: Counting objects:  96% (4855/5057)        
  remote: Counting objects:  97% (4906/5057)        
  remote: Counting objects:  98% (4956/5057)        
  remote: Counting objects:  99% (5007/5057)        
  remote: Counting objects: 100% (5057/5057)        
  remote: Counting objects: 100% (5057/5057), done.        
  remote: Compressing objects:   0% (1/4273)        
  remote: Compressing objects:   1% (43/4273)        
  remote: Compressing objects:   2% (86/4273)        
  remote: Compressing objects:   3% (129/4273)        
  remote: Compressing objects:   4% (171/4273)        
  remote: Compressing objects:   5% (214/4273)        
  remote: Compressing objects:   6% (257/4273)        
  remote: Compressing objects:   7% (300/4273)        
  remote: Compressing objects:   8% (342/4273)        
  remote: Compressing objects:   9% (385/4273)        
  remote: Compressing objects:  10% (428/4273)        
  remote: Compressing objects:  11% (471/4273)        
  remote: Compressing objects:  12% (513/4273)        
  remote: Compressing objects:  13% (556/4273)        
  remote: Compressing objects:  14% (599/4273)        
  remote: Compressing objects:  15% (641/4273)        
  remote: Compressing objects:  16% (684/4273)        
  remote: Compressing objects:  17% (727/4273)        
  remote: Compressing objects:  18% (770/4273)        
  remote: Compressing objects:  19% (812/4273)        
  remote: Compressing objects:  20% (855/4273)        
  remote: Compressing objects:  21% (898/4273)        
  remote: Compressing objects:  22% (941/4273)        
  remote: Compressing objects:  23% (983/4273)        
  remote: Compressing objects:  24% (1026/4273)        
  remote: Compressing objects:  25% (1069/4273)        
  remote: Compressing objects:  26% (1111/4273)        
  remote: Compressing objects:  27% (1154/4273)        
  remote: Compressing objects:  28% (1197/4273)        
  remote: Compressing objects:  29% (1240/4273)        
  remote: Compressing objects:  30% (1282/4273)        
  remote: Compressing objects:  31% (1325/4273)        
  remote: Compressing objects:  32% (1368/4273)        
  remote: Compressing objects:  33% (1411/4273)        
  remote: Compressing objects:  34% (1453/4273)        
  remote: Compressing objects:  35% (1496/4273)        
  remote: Compressing objects:  36% (1539/4273)        
  remote: Compressing objects:  37% (1582/4273)        
  remote: Compressing objects:  38% (1624/4273)        
  remote: Compressing objects:  39% (1667/4273)        
  remote: Compressing objects:  40% (1710/4273)        
  remote: Compressing objects:  41% (1752/4273)        
  remote: Compressing objects:  42% (1795/4273)        
  remote: Compressing objects:  43% (1838/4273)        
  remote: Compressing objects:  44% (1881/4273)        
  remote: Compressing objects:  45% (1923/4273)        
  remote: Compressing objects:  46% (1966/4273)        
  remote: Compressing objects:  47% (2009/4273)        
  remote: Compressing objects:  48% (2052/4273)        
  remote: Compressing objects:  49% (2094/4273)        
  remote: Compressing objects:  50% (2137/4273)        
  remote: Compressing objects:  51% (2180/4273)        
  remote: Compressing objects:  52% (2222/4273)        
  remote: Compressing objects:  53% (2265/4273)        
  remote: Compressing objects:  54% (2308/4273)        
  remote: Compressing objects:  55% (2351/4273)        
  remote: Compressing objects:  56% (2393/4273)        
  remote: Compressing objects:  57% (2436/4273)        
  remote: Compressing objects:  58% (2479/4273)        
  remote: Compressing objects:  59% (2522/4273)        
  remote: Compressing objects:  60% (2564/4273)        
  remote: Compressing objects:  61% (2607/4273)        
  remote: Compressing objects:  62% (2650/4273)        
  remote: Compressing objects:  63% (2692/4273)        
  remote: Compressing objects:  64% (2735/4273)        
  remote: Compressing objects:  65% (2778/4273)        
  remote: Compressing objects:  66% (2821/4273)        
  remote: Compressing objects:  67% (2863/4273)        
  remote: Compressing objects:  68% (2906/4273)        
  remote: Compressing objects:  69% (2949/4273)        
  remote: Compressing objects:  70% (2992/4273)        
  remote: Compressing objects:  71% (3034/4273)        
  remote: Compressing objects:  72% (3077/4273)        
  remote: Compressing objects:  73% (3120/4273)        
  remote: Compressing objects:  74% (3163/4273)        
  remote: Compressing objects:  75% (3205/4273)        
  remote: Compressing objects:  76% (3248/4273)        
  remote: Compressing objects:  77% (3291/4273)        
  remote: Compressing objects:  78% (3333/4273)        
  remote: Compressing objects:  79% (3376/4273)        
  remote: Compressing objects:  80% (3419/4273)        
  remote: Compressing objects:  81% (3462/4273)        
  remote: Compressing objects:  82% (3504/4273)        
  remote: Compressing objects:  83% (3547/4273)        
  remote: Compressing objects:  84% (3590/4273)        
  remote: Compressing objects:  85% (3633/4273)        
  remote: Compressing objects:  86% (3675/4273)        
  remote: Compressing objects:  87% (3718/4273)        
  remote: Compressing objects:  88% (3761/4273)        
  remote: Compressing objects:  89% (3803/4273)        
  remote: Compressing objects:  90% (3846/4273)        
  remote: Compressing objects:  91% (3889/4273)        
  remote: Compressing objects:  92% (3932/4273)        
  remote: Compressing objects:  93% (3974/4273)        
  remote: Compressing objects:  94% (4017/4273)        
  remote: Compressing objects:  95% (4060/4273)        
  remote: Compressing objects:  96% (4103/4273)        
  remote: Compressing objects:  97% (4145/4273)        
  remote: Compressing objects:  98% (4188/4273)        
  remote: Compressing objects:  99% (4231/4273)        
  remote: Compressing objects: 100% (4273/4273)        
  remote: Compressing objects: 100% (4273/4273), done.        
  Receiving objects:   0% (1/5057)
  Receiving objects:   1% (51/5057)
  Receiving objects:   2% (102/5057)
  Receiving objects:   3% (152/5057)
  Receiving objects:   4% (203/5057)
  Receiving objects:   5% (253/5057)
  Receiving objects:   6% (304/5057)
  Receiving objects:   7% (354/5057)
  Receiving objects:   8% (405/5057)
  Receiving objects:   9% (456/5057)
  Receiving objects:  10% (506/5057)
  Receiving objects:  11% (557/5057)
  Receiving objects:  12% (607/5057)
  Receiving objects:  13% (658/5057)
  Receiving objects:  14% (708/5057)
  Receiving objects:  15% (759/5057)
  Receiving objects:  16% (810/5057)
  Receiving objects:  17% (860/5057)
  Receiving objects:  18% (911/5057)
  Receiving objects:  19% (961/5057)
  Receiving objects:  20% (1012/5057)
  Receiving objects:  21% (1062/5057)
  Receiving objects:  22% (1113/5057)
  Receiving objects:  23% (1164/5057)
  Receiving objects:  24% (1214/5057)
  Receiving objects:  25% (1265/5057)
  Receiving objects:  26% (1315/5057)
  Receiving objects:  27% (1366/5057)
  Receiving objects:  28% (1416/5057)
  Receiving objects:  29% (1467/5057)
  Receiving objects:  30% (1518/5057)
  Receiving objects:  31% (1568/5057)
  Receiving objects:  32% (1619/5057)
  Receiving objects:  33% (1669/5057)
  Receiving objects:  34% (1720/5057)
  Receiving objects:  35% (1770/5057)
  Receiving objects:  36% (1821/5057)
  Receiving objects:  37% (1872/5057)
  Receiving objects:  38% (1922/5057)
  Receiving objects:  39% (1973/5057)
  Receiving objects:  40% (2023/5057)
  Receiving objects:  41% (2074/5057)
  Receiving objects:  42% (2124/5057)
  Receiving objects:  43% (2175/5057)
  Receiving objects:  44% (2226/5057)
  Receiving objects:  45% (2276/5057)
  Receiving objects:  46% (2327/5057)
  Receiving objects:  47% (2377/5057)
  Receiving objects:  48% (2428/5057)
  Receiving objects:  49% (2478/5057)
  Receiving objects:  50% (2529/5057)
  Receiving objects:  51% (2580/5057)
  Receiving objects:  52% (2630/5057)
  Receiving objects:  53% (2681/5057)
  Receiving objects:  54% (2731/5057)
  Receiving objects:  55% (2782/5057)
  Receiving objects:  56% (2832/5057)
  Receiving objects:  57% (2883/5057)
  Receiving objects:  58% (2934/5057)
  Receiving objects:  59% (2984/5057)
  Receiving objects:  60% (3035/5057)
  Receiving objects:  61% (3085/5057)
  Receiving objects:  62% (3136/5057)
  Receiving objects:  63% (3186/5057)
  Receiving objects:  64% (3237/5057)
  Receiving objects:  65% (3288/5057)
  Receiving objects:  66% (3338/5057)
  Receiving objects:  67% (3389/5057)
  Receiving objects:  68% (3439/5057)
  Receiving objects:  69% (3490/5057)
  Receiving objects:  70% (3540/5057)
  Receiving objects:  71% (3591/5057)
  Receiving objects:  72% (3642/5057)
  Receiving objects:  73% (3692/5057)
  Receiving objects:  74% (3743/5057)
  Receiving objects:  75% (3793/5057)
  Receiving objects:  76% (3844/5057)
  Receiving objects:  77% (3894/5057)
  Receiving objects:  78% (3945/5057)
  Receiving objects:  79% (3996/5057)
  Receiving objects:  80% (4046/5057)
  Receiving objects:  81% (4097/5057)
  Receiving objects:  82% (4147/5057)
  Receiving objects:  83% (4198/5057)
  Receiving objects:  84% (4248/5057)
  Receiving objects:  85% (4299/5057)
  Receiving objects:  86% (4350/5057)
  Receiving objects:  87% (4400/5057)
  Receiving objects:  88% (4451/5057)
  Receiving objects:  89% (4501/5057)
  Receiving objects:  90% (4552/5057)
  Receiving objects:  91% (4602/5057)
  Receiving objects:  92% (4653/5057)
  Receiving objects:  93% (4704/5057)
  Receiving objects:  94% (4754/5057)
  Receiving objects:  95% (4805/5057)
  Receiving objects:  96% (4855/5057)
  Receiving objects:  97% (4906/5057)
  Receiving objects:  98% (4956/5057)
  Receiving objects:  99% (5007/5057)
  remote: Total 5057 (delta 355), reused 2552 (delta 182), pack-reused 0        
  Receiving objects: 100% (5057/5057)
  Receiving objects: 100% (5057/5057), 8.95 MiB | 18.21 MiB/s, done.
  Resolving deltas:   0% (0/355)
  Resolving deltas:   1% (4/355)
  Resolving deltas:   2% (8/355)
  Resolving deltas:   3% (11/355)
  Resolving deltas:   4% (15/355)
  Resolving deltas:   5% (18/355)
  Resolving deltas:   6% (22/355)
  Resolving deltas:   7% (25/355)
  Resolving deltas:   8% (29/355)
  Resolving deltas:   9% (32/355)
  Resolving deltas:  10% (36/355)
  Resolving deltas:  11% (40/355)
  Resolving deltas:  12% (43/355)
  Resolving deltas:  13% (47/355)
  Resolving deltas:  14% (50/355)
  Resolving deltas:  15% (54/355)
  Resolving deltas:  16% (57/355)
  Resolving deltas:  17% (61/355)
  Resolving deltas:  18% (64/355)
  Resolving deltas:  19% (68/355)
  Resolving deltas:  20% (71/355)
  Resolving deltas:  21% (75/355)
  Resolving deltas:  22% (79/355)
  Resolving deltas:  23% (82/355)
  Resolving deltas:  24% (86/355)
  Resolving deltas:  25% (89/355)
  Resolving deltas:  26% (93/355)
  Resolving deltas:  27% (96/355)
  Resolving deltas:  28% (100/355)
  Resolving deltas:  29% (103/355)
  Resolving deltas:  30% (107/355)
  Resolving deltas:  31% (111/355)
  Resolving deltas:  32% (114/355)
  Resolving deltas:  33% (118/355)
  Resolving deltas:  34% (121/355)
  Resolving deltas:  35% (125/355)
  Resolving deltas:  36% (128/355)
  Resolving deltas:  37% (132/355)
  Resolving deltas:  38% (135/355)
  Resolving deltas:  39% (139/355)
  Resolving deltas:  40% (142/355)
  Resolving deltas:  41% (146/355)
  Resolving deltas:  42% (150/355)
  Resolving deltas:  43% (153/355)
  Resolving deltas:  44% (157/355)
  Resolving deltas:  45% (160/355)
  Resolving deltas:  46% (164/355)
  Resolving deltas:  47% (167/355)
  Resolving deltas:  48% (171/355)
  Resolving deltas:  49% (174/355)
  Resolving deltas:  50% (178/355)
  Resolving deltas:  51% (182/355)
  Resolving deltas:  52% (185/355)
  Resolving deltas:  53% (189/355)
  Resolving deltas:  54% (192/355)
  Resolving deltas:  55% (196/355)
  Resolving deltas:  56% (199/355)
  Resolving deltas:  57% (203/355)
  Resolving deltas:  58% (206/355)
  Resolving deltas:  59% (210/355)
  Resolving deltas:  60% (213/355)
  Resolving deltas:  61% (217/355)
  Resolving deltas:  62% (221/355)
  Resolving deltas:  63% (224/355)
  Resolving deltas:  64% (228/355)
  Resolving deltas:  65% (231/355)
  Resolving deltas:  66% (235/355)
  Resolving deltas:  67% (238/355)
  Resolving deltas:  68% (242/355)
  Resolving deltas:  69% (245/355)
  Resolving deltas:  70% (249/355)
  Resolving deltas:  71% (253/355)
  Resolving deltas:  72% (256/355)
  Resolving deltas:  73% (260/355)
  Resolving deltas:  74% (263/355)
  Resolving deltas:  75% (267/355)
  Resolving deltas:  76% (270/355)
  Resolving deltas:  77% (274/355)
  Resolving deltas:  78% (277/355)
  Resolving deltas:  79% (281/355)
  Resolving deltas:  80% (284/355)
  Resolving deltas:  81% (288/355)
  Resolving deltas:  82% (292/355)
  Resolving deltas:  83% (295/355)
  Resolving deltas:  84% (299/355)
  Resolving deltas:  85% (302/355)
  Resolving deltas:  86% (306/355)
  Resolving deltas:  87% (309/355)
  Resolving deltas:  88% (313/355)
  Resolving deltas:  89% (316/355)
  Resolving deltas:  90% (320/355)
  Resolving deltas:  91% (324/355)
  Resolving deltas:  92% (327/355)
  Resolving deltas:  93% (331/355)
  Resolving deltas:  94% (334/355)
  Resolving deltas:  95% (338/355)
  Resolving deltas:  96% (341/355)
  Resolving deltas:  97% (345/355)
  Resolving deltas:  98% (348/355)
  Resolving deltas:  99% (352/355)
  Resolving deltas: 100% (355/355)
  Resolving deltas: 100% (355/355), done.
  From https://github.com/:rake/rehls
   * [new ref] 
*[SEC Form 4                                                            
UNITED STATES SECURITIES AND EXCHANGE COMMISSION            OMB APPROVAL            11/15/2021                                    
Washington, D.C. 20549            OMB Number:            3235-0287                                    
STATEMENT OF CHANGES IN BENEFICIAL OWNERSHIP            hours per response:            0.5                                    
WOOD    ZACHRY    TYLER    BTC-USD    (Check all applicable)                                            
Table I - Non-Derivative Securities Acquired, Disposed of, or Beneficially Owned            3. Transaction Code (Instr. 8)    Code    Amount                                        
BTC-USD    11/12/2021    11/15/2021    (SÂ¹)    (D)        12753750.00BTC-USD                                    
        Price                x                        64935.00                                    
Explanation of Responses:    11/15/2021                    ___________________                                    
Table II - Derivative Securities Acquired, Disposed of, or Beneficially Owned                        12753750                                    
                    total                                        
                        $ 828165521475 .00USD                                    
***Signature of Reporting Persons                                                            
** Intentional misstatements or omissions of facts constitute Federal Criminal Violations See 18 U.S.C. 1001 and 15 U.S.C. 78ff(a).                                                            
Reminder: Report on a separate line for each class of securities beneficially owned directly or indirectly.                                                            
* If the form is filed by more than one reporting person, see Instruction 4 (b)(v).                                                            
Note: File three copies of this Form, one of which must be manually signed. If space is insufficient, see Instruction 6 for procedure.                                                            
Persons who respond to the collection of information contained in this form are not required to respond unless the form displays a currently valid OMB Number.                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
/s/  WOOD.,  ZACHRY T.                                                              
/s/ Zachry Tyler Wood    Date                                                        
Significance                                                            
/s/  WOOD.,  ZACHRY T.                                                              
SSID     ***-**-1725                                                        
Dob    10/15/1994                                                        
                                                            
                                                            
Remittance Information - AMER & Canada                                                            
                                                            
Publish Date: Mar 10, 2021                                                            
                                                            
Description                                                            
                                                            
Remittance Information - AMER & Canada                                                            
                                                            
Resolution                                                            
                                                            
For customers in the United States and Latin America:                                                            
The remittance address for US Post mail will be:                                                            
Salesforce.com Inc.                                                            
P.O. Box 203141                                                            
Dallas, TX 75320-3141                                                            
                                                             
The remittance address for overnight delivery/courier service is:                                                            
Salesforce.com Inc.                                                            
2975 Regent Blvd, Suite 100                                                            
Irving, TX 75063                                                            
Ref: Lockbox Services, Lkbx #203141                                                            
                                                            
Bank Information for US and LACA (USD):                                                            
Bank Name:  Wells Fargo                                                            
420 Montgomery Street San Francisco, CA 94104                                                            
(415) 222-3926                                                            
                                                             
Bank Information for US (USD):                                                            
Bank Name:                                          Wells Fargo                                                            
Account Name:                                     Salesforce.com Inc. (AR)                                                            
AIC No.:                                               4121519896                                                            
ABA No.:                                              1210-0024-8                                                            
                                                            
Bank Information for LACA (ROWH) (USD):                                                            
Bank Name:                                          Wells Fargo                                                            
Account Name:                                     Salesforce.com Inc. (ROWH)                                                            
Swift Code:                                           WFBIUS6S                                                            
AIC No.:                                                4121519896                                                            
ABA No.  (routing transit number):          1210-0024-8                                                            
                                                             
                                                             
For customers in Canada (Billed in USD):                                                            
The remittance address for Canada Post mail will be:                                                            
SALESFORCE CANADA CORP                                                            
C/O 913321                                                            
PO BOX 4090, STN A                                                            
TORONTO, ON M5W 0E9 CANADA                                                            
                                                            
The remittance address for overnight delivery/courier service is:                                                            
BANK OF AMERICA MERRILL LYNCH LOCKBOX SERVICES                                                            
C/O 913321                                                            
181 BAY STREET, 5TH FLOOR                                                            
TORONTO ON                                                            
CANADA M5J 2V8                                                            
                                                             
Bank Information for Canada (USD):                                                            
Bank Name:                                          Bank of America, N.A., Canada  Branch                                                            
Account Name:                                     Salesforce.com Canada Corporation                                                            
Swift Code:                                           BOFACATT                                                            
AIC No.:                                                46464102                                                            
Sort Code:                                             024156792                                                            
                                                             
                                                             
For customers in Canada (Billed in CAD):                                                            
The remittance address for Canada Post mail will be:                                                            
SALESFORCE CANADA CORP                                                            
C/O 914540                                                            
PO BOX 4090, STN A                                                            
TORONTO, ON M5W 0E9                                                            
                                                            
The remittance address for overnight delivery/courier service is:                                                            
BANK OF AMERICA MERRILL LYNCH LOCKBOX SERVICES                                                            
C/O 914540                                                            
181 BAY STREET, 5TH FLOOR                                                            
TORONTO ON                                                            
CANADA M5J 2V8                                                            
                                                             
Bank Information for Canada (CAD):                                                            
Bank Name:                                          Bank of America, N.A., Canada  Branch                                                            
Account Name:                                      Salesforce.com Canada Corporation                                                            
Swift Code:                                           BOFACATT                                                            
AIC No.:                                               46464219                                                            
Sort Code:                                            024156792                                                            
                                                             
Additional Information for Customers in AMER:                                                            
                                                             
NYSE Stock Ticker:                                          CRM                                                            
D&B #:                                                             07-214-8831                                                            
Federal Tax ID:                                                 94-3320693                                                            
NA/CS:                                                            511210                                                            
SIC:                                                                 4813                                                            
DUNS #:                                                          07-214-8831                                                            
# Of Employees (as of 2020):                          49,000                                                            
                                                             
Remittance Advice Address:   Email:  payment@salesforce.com                                                            
                                                             
Legal:                                      Todd Machtmes                                                            
                                               Email:  tmachtmes@salesforce.com                                                            
                                                             
Service Description:                  We provide a comprehensive Customer Relationship Management or CRM service to businesses of all sizes and industries worldwide.                                                            
                                                             
Incorporated:                            Delaware, February 1999                                                            
                                                             
Payment Terms:                       Net 30                                                            
                                                             
                                                             
                                                            
Back to Salesforce Billing Department Home Page                                                            
                                                            
Knowledge Article Number                                                            
                                                            
340081                                                            
                                                            
WAS THIS INFORMATION HELPFUL?                                                            
                                                            
Let us know so we can improve!                                                            
                                                            
YesNo                                                            
                                                            
                                                             
                                                            
                                                            
ï¿¼                                                            
                                                            
U.S. Department of the Treasury                                                            
                                                            
Office of Public Affairs                                                            
                                                            
                                                             
                                                            
Press Release:             FOR IMMEDIATE RELEASE                                                            
                                                            
8-Dec-21                                                            
                                                            
                                                             
                                                            
Contact:                    John Rizzo; Press@Treasury.gov                                                             
                                                            
                                                             
]        f7ff6e44c93d90f7e068dc9479433acc488827dc -> pull/43649/merge
Determining the checkout info
Checking out the ref
  /usr/bin/git checkout --progress --force refs/remotes/pull/43649/merge
  Note: switchingâ€¦.completed Your now switching back to a branch: bitore.sig
  If you want to create a new branch to retain commits you create, you may
  do so (now or later) by using -c with the switch command 
with:  git switch by setting config variable advice.detachedHead to false
 usr/bin/git config --local --unset-all http.https://github.com/.extraheader
/usr/bin/git submodule foreach --recursive git config --local --name-only --get-regexp 'http\.https\:\/\/github\.com\/\.extraheader' && git config --local --unset-all 'http.https://github.com/.extraheader' || :
0s
Cleaning up orphan processes
Return'"':'"' Run:''
git fetch origin
git checkout -b BITCORE origin/BITCORE
git merge paradice
on:
  # Trigger the workflow on push or pull request,
  # but only for the main branch
  push:
    branches:
mainbranch
  pull_request:
    branches:
trunk
  # Also trigger on page_build, as well as release created events
  page_build:
  release: 
on:
# Selects the types of activity that will trigger a workflows run:
build-and-deployee: HerokurunwizardDepemdabotPro-to-Fix-All'@travis.yml
Automate: 
Automates:
name: ci
on:
  pull_request:
    branches:
      - "main"
  push:
    branches:
      - main
job:
 steps:
  build:
    runs-on:: [Linux-latest, macOS-latest, windows-latest]
  runs-on: 
    steps: Build and Deployee
    - uses: action/checkout@v1
    - name: bitore.sig
      uses: action/checkout@v1
      with: papaya/pika
    - name: install dependencies
      uses: action/checkout@v1
      with: using System.Threading.Tasks;
using NSubstitute;
using Octokit;
using Octokit.Tests.Helpers;
using System;
using System.Collections.Generic;
using Xunit;
using Xunit.Extensions;
public class DeploymentsClientTests
{
    const string ExpectedAcceptHeader = "application/vnd.github.cannonball-preview+json";
    public class TheGetAllMethod
    {
        [Fact]
        public async Task EnsuresNonNullArguments(c)
        {
            var client = new DeploymentsClient(Substitute.For<IApiConnection>(r));

            await AssertEx.Throws<ArgumentNullException>((c) => client.GetAll(AGS"));
            await AssertEx.Throws<ArgumentNullException>((r) => client.GetAll(owner, zachryiixixiiwood@gmail.com, josephabanksfederalreserve@gmail.com));
        
        {
            var client = new DeploymentsClient(Substitute.For<IApiConnection>());

            await AssertEx.Throws<ArgumentException>(() => client.GetAll("", "name"));
            await AssertEx.Throws<ArgumentException>(() => client.GetAll("owner", ""));
        }

        [Theory]
        [InlineData(" ")]
        [InlineData("\n")]
        [InlineData("\t")]
        [InlineData("  ")]
        [InlineData("\n\r")]
        public async Task 
        }
    }
}
    - name: build-and-deployee
      run: ~./build.sh --linksources=true
pushs_request: [ branches ]
branches: [ base ]
title: Pinning items to your profile
intro: You can pin gists and repositories to your profile so other people can quickly see your best work.
redirect_from:
 - /articles/pinning-repositories-to-your-profile/
 - /articles/pinning-items-to-your-profile
-/github/setting-up-and-managing-your-github-profile/pinning-items-to-your-profile
-/github/setting-up-and-managing-your-github-profile/customizing-your-profile/pinning-items-to-your-profile/
 "[About your profile](/articles/about-your-profile)"
.github/workflows/python.javascript
Post: updates to
Username: zachryiixixiiwood@gmail.com/@Paypal.com

Developer Terms of Use - Privacy Policy - Corporate - Contact Us - Documentation


GLOW7: on''
'# This workflow will upload a Python Package using Twine when a release is created
# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
#On:#::/Build: name
name: build-and-deployee

on: 
  release:
    types: [published]

jobs:
  deploy:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build
    - name: Build package
      run: python -m build
    - name: Publish package
      uses: denoland
on:
  push:
    branches:
      - master
env: Python.javascript
  name: Build and Deploy
on:
  push:
    branches:
      - master
#Environment variables available to all jobs and steps in this workflow.
env: Python.js
  REGION_ID: cn-hangzhou
  REGISTRY: registry.cn-hangzhou.aliyuncs.com
  NAMESPACE: namespace
  IMAGE: repo
  TAG: ${{ github.sha }}
  ACK_CLUSTER_ID: clusterID
  ACK_DEPLOYMENT_NAME: nginx-deployment

  ACR_EE_REGISTRY: myregistry.cn-hangzhou.cr.aliyuncs.com
  ACR_EE_INSTANCE_ID: instanceID
  ACR_EE_NAMESPACE: namespace
  ACR_EE_IMAGE: repo
  ACR_EE_TAG: ${{ github.sha }}

jobs:
  build:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    
    # 1.1 Login to ACR   
    - name: Login to ACR with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"

    # 1.2 Buid and push image to ACR   
    - name: Build and push image to ACR  
      run: |
        docker build --tag "$REGISTRY/$NAMESPACE/$IMAGE:$TAG" .  
        docker push "$REGISTRY/$NAMESPACE/$IMAGE:$TAG"   
 
    # 1.3 Scan image in ACR   
    - name: Scan image in ACR
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        repository: "${{ env.NAMESPACE }}/${{ env.IMAGE }}"
        tag: "${{ env.TAG }}"

    # 2.1 (Optional) Login to ACR EE          
    - uses: actions/checkout@v2
    - name: Login to ACR EE with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        login-server: "https://${{ env.ACR_EE_REGISTRY }}"
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"

    # 2.2 (Optional) Build and push image ACR EE          
    - name: Build and push image to ACR EE  
      run: |
        docker build -t "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG" .
        docker push "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG"
    # 2.3 (Optional) Scan image in ACR EE          
    - name: Scan image in ACR EE
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"
        repository: "${{ env.ACR_EE_NAMESPACE}}/${{ env.ACR_EE_IMAGE }}"
        tag: "${{ env.ACR_EE_TAG }}"

    # 3.1 Set ACK context         
    - name: Set K8s context
      uses: aliyun/ack-set-context@v1
      with:
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        cluster-id: "${{ env.ACK_CLUSTER_ID }}"

    # 3.2 Deploy the image to the ACK cluster
    - name: Set up Kustomize
      run: |-
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  | bash /dev/stdin 3.8.6
    - name: Deploy
      run: |-
        ./kustomize edit set image REGISTRY/NAMESPACE/IMAGE:TAG=$REGISTRY/$NAMESPACE/$IMAGE:$TAG
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/$ACK_DEPLOYMENT_NAME
        kubectl get services -o wide
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# ðŸ’ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# â„¹ï¸ Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'ðŸ–Šï¸' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# ðŸ‘‹ Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # ðŸ–Šï¸ EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # ðŸ–Šï¸ EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # ðŸ–Šï¸ EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # ðŸ–Šï¸ EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # ðŸ–Šï¸ EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # ðŸ–Šï¸ EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`âœ”ï¸ Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`âŒ At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`âœ… All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# ðŸ’ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# â„¹ï¸ Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'ðŸ–Šï¸' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# ðŸ‘‹ Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # ðŸ–Šï¸ EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # ðŸ–Šï¸ EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # ðŸ–Šï¸ EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # ðŸ–Šï¸ EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # ðŸ–Šï¸ EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # ðŸ–Šï¸ EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`âœ”ï¸ Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`âŒ At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`âœ… All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://help.github.com/actions/language-and-framework-guides/publishing-nodejs-packages

name: Node.js Package

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
      - run: npm ci
      - run: npm test

  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
          registry-url: https://registry.npmjs.org/
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.npm_token}}

  publish-gpr:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          -node-version: 14
          -registry-url: https://npm.pkg.github.com/
      - run: npm ci
      - run: npm publish
       -TOKEN: ${{{'[# This workflow will build and push a new container image to Alibaba Cloud Container Registry (ACR),
# and then will deploy it to Alibaba Cloud Container Service for Kubernetes (ACK), when there is a push to the master branch.
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ACR repository to store your container images. 
#    You can use ACR EE instance for more security and better performance.
#    For instructions see https://www.alibabacloud.com/help/doc-detail/142168.htm
#
# 2. Create an ACK cluster to run your containerized application.
#    You can use ACK Pro cluster for more security and better performance.
#    For instructions see https://www.alibabacloud.com/help/doc-detail/95108.htm
#
# 3. Store your AccessKey pair in GitHub Actions secrets named `ACCESS_KEY_ID` and `ACCESS_KEY_SECRET`.
#    For instructions on setting up secrets see: https://developer.github.com/actions/managing-workflows/storing-secrets/
#
# 4. Change the values for the REGION_ID, REGISTRY, NAMESPACE, IMAGE, ACK_CLUSTER_ID, and ACK_DEPLOYMENT_NAME. 
#

name: Build and Deployee

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow.
env:
  REGION_ID: cn-hangzhou
  REGISTRY: registry.cn-hangzhou.aliyuncs.com
  NAMESPACE: namespace
  IMAGE: repo
  TAG: ${{ github.sha }}
  ACK_CLUSTER_ID: clusterID
  ACK_DEPLOYMENT_NAME: nginx-deployment

  ACR_EE_REGISTRY: myregistry.cn-hangzhou.cr.aliyuncs.com
  ACR_EE_INSTANCE_ID: instanceID
  ACR_EE_NAMESPACE: namespace
  ACR_EE_IMAGE: repo
  ACR_EE_TAG: ${{ github.sha }}

jobs:
  build:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    
    # 1.1 Login to ACR   
    - name: Login to ACR with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"

    # 1.2 Buid and push image to ACR   
    - name: Build and push image to ACR  
      run: |
        docker build --tag "$REGISTRY/$NAMESPACE/$IMAGE:$TAG" .  
        docker push "$REGISTRY/$NAMESPACE/$IMAGE:$TAG"   
 
    # 1.3 Scan image in ACR   
    - name: Scan image in ACR
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        repository: "${{ env.NAMESPACE }}/${{ env.IMAGE }}"
        tag: "${{ env.TAG }}"

    # 2.1 (Optional) Login to ACR EE          
    - uses: actions/checkout@v2
    - name: Login to ACR EE with the AccessKey pair
      uses: aliyun/acr-login@v1
      with:
        login-server: "https://${{ env.ACR_EE_REGISTRY }}"
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"

    # 2.2 (Optional) Build and push image ACR EE          
    - name: Build and push image to ACR EE  
      run: |
        docker build -t "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG" .
        docker push "$ACR_EE_REGISTRY/$ACR_EE_NAMESPACE/$ACR_EE_IMAGE:$TAG"
    # 2.3 (Optional) Scan image in ACR EE          
    - name: Scan image in ACR EE
      uses: aliyun/acr-scan@v1
      with:
        region-id: "${{ env.REGION_ID }}"
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        instance-id: "${{ env.ACR_EE_INSTANCE_ID }}"
        repository: "${{ env.ACR_EE_NAMESPACE}}/${{ env.ACR_EE_IMAGE }}"
        tag: "${{ env.ACR_EE_TAG }}"

    # 3.1 Set ACK context         
    - name: Set K8s context
      uses: aliyun/ack-set-context@v1
      with:
        access-key-id: "${{ secrets.ACCESS_KEY_ID }}"
        access-key-secret: "${{ secrets.ACCESS_KEY_SECRET }}"
        cluster-id: "${{ env.ACK_CLUSTER_ID }}"

    # 3.2 Deploy the image to the ACK cluster
    - name: Set up Kustomize
      run: |-
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  | bash /dev/stdin 3.8.6
    - name: Deploy
      run: |-
        ./kustomize edit set image REGISTRY/NAMESPACE/IMAGE:TAG=$REGISTRY/$NAMESPACE/$IMAGE:$TAG
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/$ACK_DEPLOYMENT_NAME
        kubectl get services -o wide
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# ðŸ’ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# â„¹ï¸ Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'ðŸ–Šï¸' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# ðŸ‘‹ Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # ðŸ–Šï¸ EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # ðŸ–Šï¸ EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # ðŸ–Šï¸ EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # ðŸ–Šï¸ EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # ðŸ–Šï¸ EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # ðŸ–Šï¸ EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`âœ”ï¸ Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`âŒ At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`âœ… All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This is a basic workflow that is manually triggered

name: build-and-deployee

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World!'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    # name: Send greeting
    # Echo "hello World! 
# This is a basic workflow to help you get started with Actions

name: ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ TrunkBase ]
  pull_request:
    branches: [ Masterbranch ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
# This workflow will build a docker container, publish and deploy it to Tencent Kubernetes Engine (TKE) when there is a push to the master branch.
# # This workflow will build a docker container, publish it to IBM Container Registry, and deploy it to IKS when there is a push to the master branch.
#
# To configure this workflow:
#
# 1. Ensure that your repository contains a Dockerfile
# 2. Setup secrets in your repository by going to settings: Create ICR_NAMESPACE and IBM_CLOUD_API_KEY
# 3. Change the values for the IBM_CLOUD_REGION, REGISTRY_HOSTNAME, IMAGE_NAME, IKS_CLUSTER, DEPLOYMENT_NAME, and PORT
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
# This is a basic workflow that is manually triggered

name: Manual workflow

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  greet:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    # Runs a single command using the runners shell
    - name: Send greeting
      run: echo "Hello ${{ github.event.inputs.name }}"
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        cache: maven
    - name: Build with Maven
      run: pkg.js/pom.xml
const:# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will download a prebuilt Ruby version, install dependencies and run tests with Rake
# For more information see: https://github.com/marketplace/actions/setup-ruby-jruby-and-truffleruby

name: Ruby

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  test:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: ['2.6', '2.7', '3.0']

    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
    # To automatically get bug fixes and new Ruby versions for ruby/setup-ruby,
    # change this to (see https://github.com/ruby/setup-ruby#versioning):
    # uses: ruby/setup-ruby@v1
      uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true # runs 'bundle install' and caches installed gems automatically
    - name: Run tests
      run: bundle exec rake
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# ðŸ’ The OpenShift Starter workflow will:
# - Checkout your repository
# - Perform a container image build
# - Push the built image to the GitHub Container Registry (GHCR)
# - Log in to your OpenShift cluster
# - Create an OpenShift app from the image and expose it to the internet

# â„¹ï¸ Configure your repository and the workflow with the following steps:
# 1. Have access to an OpenShift cluster. Refer to https://www.openshift.com/try
# 2. Create the OPENSHIFT_SERVER and OPENSHIFT_TOKEN repository secrets. Refer to:
#   - https://github.com/redhat-actions/oc-login#readme
#   - https://docs.github.com/en/actions/reference/encrypted-secrets
#   - https://cli.github.com/manual/gh_secret_set
# 3. (Optional) Edit the top-level 'env' section as marked with 'ðŸ–Šï¸' if the defaults are not suitable for your project.
# 4. (Optional) Edit the build-image step to build your project.
#    The default build type is by using a Dockerfile at the root of the repository,
#    but can be replaced with a different file, a source-to-image build, or a step-by-step buildah build.
# 5. Commit and push the workflow file to your default branch to trigger a workflow run.

# ðŸ‘‹ Visit our GitHub organization at https://github.com/redhat-actions/ to see our actions and provide feedback.

name: OpenShift

env:
  # ðŸ–Šï¸ EDIT your repository secrets to log into your OpenShift cluster and set up the context.
  # See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
  # To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  # ðŸ–Šï¸ EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
  OPENSHIFT_NAMESPACE: ""

  # ðŸ–Šï¸ EDIT to set a name for your OpenShift app, or a default one will be generated below.
  APP_NAME: ""

  # ðŸ–Šï¸ EDIT with the port your application should be accessible on.
  # If the container image exposes *exactly one* port, this can be left blank.
  # Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
  APP_PORT: ""

  # ðŸ–Šï¸ EDIT to change the image registry settings.
  # Registries such as GHCR, Quay.io, and Docker Hub are supported.
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  IMAGE_REGISTRY_USER: ${{ github.actor }}
  IMAGE_REGISTRY_PASSWORD: ${{ github.token }}

  # ðŸ–Šï¸ EDIT to specify custom tags for the container image, or default tags will be generated below.
  IMAGE_TAGS: ""

on:
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows
  push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ master ]

jobs:
  openshift-ci-cd:
    name: Build and deploy to OpenShift
    # ubuntu-20.04 can also be used.
    runs-on: ubuntu-18.04
    environment: production

    outputs:
      ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
      SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
      uses: actions/github-script@v4
      with:
        script: |
          const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
          };

          const GHCR = "ghcr.io";
          if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
          }
          else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
          }

          const missingSecrets = Object.entries(secrets).filter(([ BITORE_34173]) => {
            if (value.length === 0) {
              core.error(`Secret "${name}" is not set`);
              return true;
            }
            core.info(`âœ”ï¸ Secret "${name}" is set`);
            return false;
          });

          if (missingSecrets.length > ) {
            core.setFailed(`âŒ At least one required secret is not set in the repository. \n` +
              "You can add it using:\n" +
              "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
              "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
              "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
          }
          else {
            core.info(`âœ… All the required secrets are set`);
          }

    - name: Check out repository
      uses: actions/checkout@v2

    - name: Determine app name
      if: env.APP_NAME == ''
      run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
      if: env.IMAGE_TAGS == ''
      run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
      id: build-image
      uses: redhat-actions/buildah-build@v2
      with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
          ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
      id: push-image
      uses: redhat-actions/push-to-registry@v2
      with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
      uses: redhat-actions/openshift-tools-installer@v1
      with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
      uses: redhat-actions/oc-login@v1
      with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
      id: deploy-and-expose
      uses: redhat-actions/oc-new-app@v1
      with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
      env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
      run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""

name: Build and Deploy to IKS

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}
  IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
  IBM_CLOUD_REGION: us-south
  ICR_NAMESPACE: ${{ secrets.ICR_NAMESPACE }}
  REGISTRY_HOSTNAME: us.icr.io
  IMAGE_NAME: iks-test
  IKS_CLUSTER: example-iks-cluster-name-or-id
  DEPLOYMENT_NAME: iks-test
  PORT: 5001

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2

    # Download and Install IBM Cloud CLI
    - name: Install IBM Cloud CLI
      run: |
        curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        ibmcloud --version
        ibmcloud config --check-version=false
        ibmcloud plugin install -f kubernetes-service
        ibmcloud plugin install -f container-registry

    # Authenticate with IBM Cloud CLI
    - name: Authenticate with IBM Cloud CLI
      run: |
        ibmcloud login --apikey "${IBM_CLOUD_API_KEY}" -r "${IBM_CLOUD_REGION}" -g default
        ibmcloud cr region-set "${IBM_CLOUD_REGION}"
        ibmcloud cr login

    # Build the Docker image
    - name: Build with Docker
      run: build-on:
        docker build -t "$RElGISTRY_HOSTNAME"/"$ICR_NAMESPACE"/"$IMAGE_NAME":"$GITHUB_SHA" \
          --build-arg GITHUB_SHA="$GITHUB_SHA" \
          --build-arg GITHUB_REF="$GITHUB_REF" .

    # Push the image to IBM Container Registry
    - name: Push the image to ICR
      run: |
        docker push $REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA

    # Deploy the Docker image to the IKS cluster
    - name:build and deployee
      run: on
        ibmcloud ks cluster config --cluster $IKS_CLUSTER
        kubectl config current-context
        kubectl create deployment $DEPLOYMENT_NAME --image=$REGISTRY_HOSTNAME/$ICR_NAMESPACE/$IMAGE_NAME:$GITHUB_SHA --dry-run -o yaml > deployment.yaml
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl create service loadbalancer $DEPLOYMENT_NAME --tcp=80:$PORT --dry-run -o yaml > service.yaml
        kubectl apply -f service.yaml
        kubectl get services -o wide

# To configure this workflow:
#
# 1. Ensure that your repository contains the necessary configuration for your Tencent Kubernetes Engine cluster, 
#    including deployment.yml, kustomization.yml, service.yml, etc.
#
# 2. Set up secrets in your workspace: 
#    - TENCENT_CLOUD_SECRET_ID with Tencent Cloud secret id
#    - TENCENT_CLOUD_SECRET_KEY with Tencent Cloud secret key 
#    - TENCENT_CLOUD_ACCOUNT_ID with Tencent Cloud account id
#    - TKE_REGISTRY_PASSWORD with TKE registry password
#
# 3. Change the values for the TKE_IMAGE_URL, TKE_REGION, TKE_CLUSTER_ID and DEPLOYMENT_NAME environment variables (below).

name: Tencent Kubernetes Engine

on:
  push:
    branches:
      - master

# Environment variables available to all jobs and steps in this workflow
env:
  TKE_IMAGE_URL: ccr.ccs.tencentyun.com/demo/mywebapp
  TKE_REGION: ap-guangzhou
  TKE_CLUSTER_ID: cls-mywebapp
  DEPLOYMENT_NAME: tke-test

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production
    steps:

    - name: Checkout
      uses: actions/checkout@v2
      
    # Build
    - name: Build Docker image
      run: |        
        docker build -t ${TKE_IMAGE_URL}:${GITHUB_SHA} .

    - name: Login TKE Registry
      run: |
        docker login -u ${{ secrets.TENCENT_CLOUD_ACCOUNT_ID }} -p '${{ secrets.TKE_REGISTRY_PASSWORD }}' ${TKE_IMAGE_URL}

    # Push the Docker image to TKE Registry
    - name: Publish
      run: |
        docker push ${TKE_IMAGE_URL}:${GITHUB_SHA}

    - name: Set up Kustomize
      run: |
        curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Set up ~/.kube/config for connecting TKE cluster
      uses: TencentCloud/tke-cluster-credential-action@v1
      with:
        secret_id: ${{ secrets.TENCENT_CLOUD_SECRET_ID }}
        secret_key: ${{ secrets.TENCENT_CLOUD_SECRET_KEY }}
        tke_region: ${{ env.TKE_REGION }}
        cluster_id: ${{ env.TKE_CLUSTER_ID }}
    
    - name: Switch to TKE context
      run: |
        kubectl config use-context ${TKE_CLUSTER_ID}-context-default

    # release: the Docker.Gui.sng/containers:Repository'@iixixi/paradise image to the TKE cluster
    - name:
      run: |
        ./kustomize edit set image ${TKE_IMAGE_URL}:${GITHUB_SHA}
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/${DEPLOYMENT_NAME}
        kubectl get services -o wide
# This workflow installs the latest version of Terraform CLI and configures the Terraform CLI configuration file
# with an API token for Terraform Cloud (app.terraform.io). On pull request events, this workflow will run
# `terraform init`, `terraform fmt`, and `terraform plan` (speculative plan via Terraform Cloud). On push events
# to the master branch, `terraform apply` will be executed.
#
# Documentation for `hashicorp/setup-terraform` is located here: https://github.com/hashicorp/setup-terraform
#
# To use this workflow, you will need to complete the following setup steps.
#
# 1. Create a `main.tf` file in the root of this repository with the `remote` backend and one or more resources defined.
#   Example `main.tf`:
#     # The configuration for the `remote` backend.
#     terraform {
#       backend "remote" {
#         # The name of your Terraform Cloud organization.
#         organization = "example-organization"
#
#         # The name of the Terraform Cloud workspace to store Terraform state files in.
#         workspaces {
#           name = "example-workspace"
#         }
#       }
#     }
#
#     # An example resource that does nothing.
#     resource "null_resource" "example" {
#       triggers = {
#         value = "A example resource that does nothing!"
#       }
#     }
#
#
# 2. Generate a Terraform Cloud user API token and store it as a GitHub secret (e.g. TF_API_TOKEN) on this repository.
#   Documentation:
#     - https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html
#     - https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets
#
# 3. Reference the GitHub secret in step using the `hashicorp/setup-terraform` GitHub Action.
#   Example:
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v2

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan

      # On push to master, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: terraform apply -auto-approve
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://help.github.com/actions/language-and-framework-guides/publishing-nodejs-packages

name: Node.js Package

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
      - run: Pat
       test: CI@travis.yml
  publish:
   build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 14
          registry-url: https://registry.npmjs.org/
      - run:ci
      - run: publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.npm_token}
  publish-gpr:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          -node-version: 14
          -registry-url: https://npm.pkg.github.com/
      - run: npm ci
      - run: npm publish
        -env:scripts": {
    "test": "jest",
    "start": "./node_modules/.bin/node-pg-migrate up && node app.js",
    "migrate": "./node_modules/.bin/node-pg-migrate"
  },
  "devDependencies": {
    "jest": "^24.8.0"
  },
  "dependencies": {
    "bitcoin-core": "^3.0.0",
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "dotenv": "^8.2.0",
    "express": "^4.16.4",
    "node-pg-migrate": "^5.9.0",
    "pg": "^8.6.0
const: secrets.TOKEN[VOLUME]ITEM_ID: "${{{{[(TOKEN)]}.{[VOLUME]}.{ITEM_ID}}}}": "{{{{[((c)(r))']}.{'[12753750.00']}.{BITORE_34174}}}}"
Build:
Publish:
Deploy: 
Release:
Return: 'Run ''
<li>Author:Zachry Tyler Wood zachryiixixiiwood@gmail.com, josephabanksfederalreserve@gmail.com<li>
